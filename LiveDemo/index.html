<!DOCTYPE html>
<html lang="en" charset="utf-8" style="width:100%">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

  <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <meta name="apple-mobile-web-app-capable"          content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
  <meta name="format-detection"                      content="telephone=no">

  <style name="mobile-prologue">
    html {
      text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -webkit-text-size-adjust: 100%;
      -o-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }

    html, body {
      width:99%; height:99%;
    }

    html { overflow:hidden scroll }
  </style>

  <style name="white-textured-background">
    html, body {
      background-color: white;
      background-image: url(./BinaryTexture_white.jpg);
      background-repeat:repeat;

      font-family:'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif;
      font-size:14px; font-weight:400; color:black;
      line-height:150%;
    }

    * {
      -moz-box-sizing:border-box; -webkit-box-sizing:border-box; box-sizing:border-box;
    }
  </style>
  <script name="clear-console">
    if (typeof console.clear === 'function') {
      console.clear()
    }
  </script>

  <script src="https://unpkg.com/blockly/blockly_compressed.js"></script>
  <script src="https://unpkg.com/blockly/blocks_compressed.js"></script>
  <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly/msg/en.js"></script>
  <script src="https://rozek.github.io/JS-Interpreter/acorn_interpreter.js"></script>
  <script type="importmap">
  {
    "imports": {
      "javascript-interface-library":"https://rozek.github.io/javascript-interface-library/dist/javascript-interface-library.esm.js",
      "htm/preact":                  "https://rozek.github.io/htm/preact/standalone.module.js",
      "hyperactiv":                  "https://rozek.github.io/hyperactiv/dist/index.mjs",
      "html-to-text":                "https://cdn.jsdelivr.net/npm/html-to-text@9.0.5/+esm"
    }
  }
  </script>
  <script name="download"    src="https://rozek.github.io/download/download.min.js"></script>
  <script name="localforage" src="https://rozek.github.io/localForage/dist/localforage.min.js"></script>

  <style>
/*******************************************************************************
*                                                                              *
*                            Blockly AI Playground                             *
*                                                                              *
*******************************************************************************/

  :disabled { opacity:0.3 }

  .Playground {
    display:block; position:relative;
  }

  .Playground.View {
    display:flex; position:absolute; flex-flow:column nowrap;
      justify-content:flex-start; align-items:stretch;
    left:0px; top:0px; right:0px; bottom:0px;
    padding:10px;
  }

  .Playground.Title {
    font-size:18px; font-weight:bold;
  }

  .Playground.Strip {
    display:flex; flex-flow:row nowrap;
      justify-content:flex-start; align-items:center;
    padding:10px 0px 4px 0px;
  }

  .Playground.Gap {
    display:inline-block;
    flex:1 0 auto;
  }

  .Playground.Tab {
    display:inline-block;
    border:solid 3px transparent;
  }
  .Playground.Tab.active {
    border-bottom:solid 3px darkgray;
  }

  .Playground.Button {
    display:inline-block;
  }

  .Playground.Arena {
    flex:1 1 auto;
    margin:4px 0px 0px 0px;
  }

  .Playground.Workspace {
    display:none; position:absolute;
    left:0px; top:0px; right:0px; bottom:0px;
  }
  .Playground.Workspace.active {
    display:flex; flex-flow:column nowrap;
      justify-content:flex-start; align-items:stretch;
  }

  .Playground.Workspace > .Placeholder {
    flex:1 1 auto;
  }

  .Playground.FileInput {
    display:block; position:absolute;
    left:0px; top:0px; right:0px; bottom:0px;
  }

  .Playground.UI {
    display:none; position:absolute;
    left:0px; top:0px; right:0px; bottom:0px;
    overflow-x:auto; overflow-y:scroll; overflow:auto scroll;
  }
  .Playground.UI.active {
    display:flex; flex-flow:row wrap;
      justify-content:flex-start; align-items:flex-start;
      align-content:flex-start;
  }

  .Playground.UI.Label {
    display:inline-block; position:relative;
    flex:0 0 auto;
    min-width:180px; height:30px; overflow:visible;
    padding:0px 4px 2px 0px;
    font-weight:bold; line-height:30px;
  }

  .Playground.UI.Element {
    display:inline-block; position:relative;
    flex:1 0 auto; min-width:80px; overflow:visible;
    padding:0px 0px 2px 0px;
  }

  .Playground.UI.newLine {
    display:inline-block; position:relative;
    flex-basis:100%; height:0px; overflow:visible;
  }

/**** Textline/Password/Number/URL/TextInput ****/

  .Playground.UI.Element.TextlineInput,
  .Playground.UI.Element.PasswordInput,
  .Playground.UI.Element.NumberInput,
  .Playground.UI.Element.URLInput,
  .Playground.UI.Element.TextInput {
    top:1px;
    border:solid 1px #888888; border-radius:2px;
    background:#e8f0ff;
    padding:0px 2px 0px 2px;
  }

  .Playground.UI.Element.TextlineInput,
  .Playground.UI.Element.PasswordInput,
  .Playground.UI.Element.NumberInput,
  .Playground.UI.Element.URLInput {
    height:28px;
  }

  .Playground.UI.Element.TextInput {
    min-height:88px;
  }

  .Playground.UI.Element.NumberInput {
    flex:0 0 auto;
  }

  .Playground.UI.Element.TextlineInput:read-only,
  .Playground.UI.Element.PasswordInput:read-only,
  .Playground.UI.Element.NumberInput:read-only,
  .Playground.UI.Element.URLInput:read-only,
  .Playground.UI.Element.TextInput:read-only {
    border:solid 1px #DDDDDD; border-radius:2px;
    background:#F0F0F0;
  }

/**** Checkbox, Radiobutton ****/

  .Playground.UI.Element.Checkbox,
  .Playground.UI.Element.Radiobutton {
    flex:0 0 auto;
    top:6px; min-width:0px; margin-left:0px;
  }

/**** Button ****/

  .Playground.UI.Element.Button {
    flex:0 0 auto;
    top:1px; height:28px;
    border:solid 1px black; border-radius:4px;
    background:white;
    font-weight:bold; color:black; text-align:center;
  }

/**** DropDown ****/

  .Playground.UI.Element.DropDown {
    flex:0 0 auto;
    top:1px; height:28px;
    border:solid 1px #888888; border-radius:2px;
    background:#e8f0ff;
    padding:0px 2px 0px 2px;
  }

/**** Textline/Number/Text/FinePrintOutput ****/

  .Playground.UI.Element.TextlineOutput,
  .Playground.UI.Element.NumberOutput,
  .Playground.UI.Element.TextOutput {
    top:1px;
    border:solid 1px #DDDDDD; border-radius:2px;
    background:#F0F0F0;
    padding:0px 2px 0px 2px;
  }

  .Playground.UI.Element.TextlineOutput,
  .Playground.UI.Element.NumberOutput {
    height:28px;
  }

  .Playground.UI.Element.TextOutput {
    min-height:88px;
  }

  .Playground.UI.Element.FinePrintOutput {
    top:1px; min-height:28px;
    font-size:12px; font-weight:normal; line-height:18px;
  }

  .Playground.UI.Element.NumberOutput {
    flex:0 0 auto;
  }

/**** Text/HintView ****/

  .Playground.UI.Element.TextView {
    top:1px; min-height:28px;
    font-size:14px; font-weight:normal; line-height:21px;
  }

  .Playground.UI.Element.FinePrintView {
    top:1px; min-height:28px;
    font-size:12px; font-weight:normal; line-height:18px;
  }


  </style>
 </head>
 <body>
  <script type="module">
/*******************************************************************************
*                                                                              *
*                            Blockly AI Playground                             *
*                                                                              *
*******************************************************************************/
const { Order, javascriptGenerator } = javascript;
import { quoted, ValueIsBoolean, ValueIsNumber, ValueIsNumberInRange, ValueIsInteger, ValueIsIntegerInRange, ValueIsOrdinal, ValueIsCardinal, ValueIsString, ValueIsNonEmptyString, ValueIsStringMatching, ValueIsText, ValueIsTextline, ValueIsPlainObject, ValueIsList, ValueIsListSatisfying, ValueIsOneOf, ValueIsFunction, ValueIsColor, ValueIsEMailAddress, ValueIsURL, ValidatorForClassifier, acceptNil, rejectNil, expectBoolean, expectNumber, expectIntegerInRange, expectOrdinal, allowString, expectNonEmptyString, expectText, expectedText, expectTextline, allowPlainObject, expectPlainObject, expectListSatisfying, expectOneOf, expectURL, } from 'javascript-interface-library';
import { render, html, Component } from 'htm/preact';
import hyperactiv from 'hyperactiv';
const { observe, computed } = hyperactiv;
import { htmlToText } from 'html-to-text';
/**** throwError - simplifies construction of named errors ****/
export function throwError(Message) {
    let Match = /^([$a-zA-Z][$a-zA-Z0-9]*):\s*(\S.+)\s*$/.exec(Message);
    if (Match == null) {
        throw new Error(Message);
    }
    else {
        let namedError = new Error(Match[2]);
        namedError.name = Match[1];
        throw namedError;
    }
}
//------------------------------------------------------------------------------
//--                 Classification and Validation Functions                  --
//------------------------------------------------------------------------------
/**** ValueIsIdentifier ****/
const SNS_IdentifierPattern = /^[a-z$_][a-z$_0-9]*$/i;
function ValueIsIdentifier(Value) {
    return ValueIsStringMatching(Value, SNS_IdentifierPattern);
}
/**** allow/expect[ed]Identifier ****/
const allowIdentifier = ValidatorForClassifier(ValueIsIdentifier, acceptNil, 'note stickers identifier'), allowedIdentifier = allowIdentifier;
const expectIdentifier = ValidatorForClassifier(ValueIsIdentifier, rejectNil, 'note stickers identifier'), expectedIdentifier = expectIdentifier;
//------------------------------------------------------------------------------
//--                               Acceptables                                --
//------------------------------------------------------------------------------
/**** acceptableBoolean ****/
function acceptableBoolean(Value, Default) {
    return (ValueIsBoolean(Value) ? Value : Default);
}
/**** acceptableOptionalBoolean ****/
function acceptableOptionalBoolean(Value, Default) {
    return (Value == null
        ? undefined
        : ValueIsBoolean(Value) ? Value : Default);
}
/**** acceptableNumber ****/
function acceptableNumber(Value, Default) {
    return (ValueIsNumber(Value) ? Value : Default);
}
/**** acceptableOptionalNumber ****/
function acceptableOptionalNumber(Value, Default) {
    return (ValueIsNumber(Value) ? Value : Default);
}
/**** acceptableNumberInRange ****/
function acceptableNumberInRange(Value, Default, minValue = -Infinity, maxValue = Infinity, withMin = false, withMax = false) {
    return (ValueIsNumberInRange(Value, minValue, maxValue, withMin, withMax) ? Value : Default);
}
/**** acceptableOptionalNumberInRange ****/
function acceptableOptionalNumberInRange(Value, Default, minValue = -Infinity, maxValue = Infinity, withMin = false, withMax = false) {
    return (ValueIsNumberInRange(Value, minValue, maxValue, withMin, withMax)
        ? Value
        : Default);
}
/**** acceptableInteger ****/
function acceptableInteger(Value, Default) {
    return (ValueIsInteger(Value) ? Value : Default);
}
/**** acceptableOptionalInteger ****/
function acceptableOptionalInteger(Value, Default) {
    return (ValueIsInteger(Value) ? Value : Default);
}
/**** acceptableIntegerInRange ****/
function acceptableIntegerInRange(Value, Default, minValue = -Infinity, maxValue = Infinity) {
    return (ValueIsIntegerInRange(Value, minValue, maxValue) ? Value : Default);
}
/**** acceptableOptionalIntegerInRange ****/
function acceptableOptionalIntegerInRange(Value, Default, minValue = -Infinity, maxValue = Infinity) {
    return (ValueIsIntegerInRange(Value, minValue, maxValue) ? Value : Default);
}
/**** acceptableOrdinal ****/
function acceptableOrdinal(Value, Default) {
    return (ValueIsOrdinal(Value) ? Value : Default);
}
/**** acceptableOptionalOrdinal ****/
function acceptableOptionalOrdinal(Value, Default) {
    return (ValueIsOrdinal(Value) ? Value : Default);
}
/**** acceptableString ****/
function acceptableString(Value, Default) {
    return (ValueIsString(Value) ? Value : Default);
}
/**** acceptableOptionalString ****/
function acceptableOptionalString(Value, Default) {
    return (ValueIsString(Value) ? Value : Default);
}
/**** acceptableNonEmptyString ****/
function acceptableNonEmptyString(Value, Default) {
    return (ValueIsString(Value) && (Value.trim() !== '') ? Value : Default);
}
/**** acceptableOptionalNonEmptyString ****/
function acceptableOptionalNonEmptyString(Value, Default) {
    return (ValueIsString(Value) && (Value.trim() !== '') ? Value : Default);
}
/**** acceptableStringMatching ****/
function acceptableStringMatching(Value, Default, Pattern) {
    return (ValueIsStringMatching(Value, Pattern) ? Value : Default);
}
/**** acceptableOptionalStringMatching ****/
function acceptableOptionalStringMatching(Value, Default, Pattern) {
    return (ValueIsStringMatching(Value, Pattern) ? Value : Default);
}
/**** acceptableText ****/
const noCtrlCharsButCRLFTABPattern = /^[^\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F\u2028\u2029\uFFF9-\uFFFB]*$/;
function acceptableText(Value, Default) {
    return (ValueIsStringMatching(Value, noCtrlCharsButCRLFTABPattern) ? Value : Default);
}
/**** acceptableOptionalText ****/
function acceptableOptionalText(Value, Default) {
    return (ValueIsText(Value) ? Value : Default);
}
/**** acceptableTextline ****/
function acceptableTextline(Value, Default) {
    return (ValueIsTextline(Value) ? Value : Default).replace(/[\f\r\n\v\u0085\u2028\u2029].*$/, '...');
}
/**** acceptableOptionalTextline ****/
function acceptableOptionalTextline(Value, Default) {
    const Result = ValueIsTextline(Value) ? Value : Default;
    return (Result == null
        ? undefined
        : Result.replace(/[\f\r\n\v\u0085\u2028\u2029].*$/, '...'));
}
/**** acceptableFunction ****/
function acceptableFunction(Value, Default) {
    return (ValueIsFunction(Value) ? Value : Default);
}
/**** acceptableOptionalFunction ****/
function acceptableOptionalFunction(Value, Default) {
    return (ValueIsFunction(Value) ? Value : Default);
}
/**** acceptableList ****/
function acceptableList(Value, Default) {
    return (ValueIsList(Value) ? Value : Default);
}
/**** acceptableOptionalList ****/
function acceptableOptionalList(Value, Default) {
    return (ValueIsList(Value) ? Value : Default);
}
/**** acceptableListSatisfying ****/
function acceptableListSatisfying(Value, Default, Matcher) {
    return (ValueIsListSatisfying(Value, Matcher) ? Value : Default);
}
/**** acceptableOptionalListSatisfying ****/
function acceptableOptionalListSatisfying(Value, Default, Matcher) {
    return (ValueIsListSatisfying(Value, Matcher) ? Value : Default);
}
/**** acceptableColor ****/
function acceptableColor(Value, Default) {
    return (ValueIsColor(Value) ? Value : Default);
}
/**** acceptableOptionalColor ****/
function acceptableOptionalColor(Value, Default) {
    return (ValueIsColor(Value) ? Value : Default);
}
/**** acceptableEMailAddress ****/
function acceptableEMailAddress(Value, Default) {
    return (ValueIsEMailAddress(Value) ? Value : Default);
}
/**** acceptableURL ****/
function acceptableURL(Value, Default) {
    return (ValueIsURL(Value) ? Value : Default);
}
//------------------------------------------------------------------------------
//--                             Playground State                             --
//------------------------------------------------------------------------------
let Playground = observe({
    View: undefined,
    activeTab: 0,
    WorkspaceElement: undefined, Workspace: undefined, BackupWanted: false,
    Interpreter: undefined, InterpreterState: 'idle', pendingInterpreterState: undefined,
    UI: [], UIEnabling: true,
    UIEventQueue: [], currentUIEvent: undefined, UIEventTimer: undefined,
    UIEventHandler: undefined, UIEventHandlerState: undefined,
    thrownException: undefined,
}, { deep: false });
//------------------------------------------------------------------------------
//--                            Playground Context                            --
//------------------------------------------------------------------------------
Playground.Context = observe({}, { deep: false });
/**** ContextKeys ****/
function ContextKeys() {
    return Array.from(Object.keys(Playground.Context)).sort();
}
/**** clearContext ****/
function clearContext() {
    Object.keys(Playground.Context).forEach((Key) => delete Playground.Context[Key]);
}
/**** getFromContext ****/
function getFromContext(Key) {
    expectIdentifier('context item key', Key);
    return Playground.Context[Key];
}
/**** setInContext ****/
function setInContext(Key, Value) {
    expectIdentifier('context item key', Key);
    allowString('context item value', Value);
    if (Value == null) {
        delete Playground.Context[Key];
    }
    else {
        Playground.Context[Key] = Value;
    }
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index >= 0) {
        rerenderPlayground();
    }
}
/**** removeFromContext ****/
function removeFromContext(Key) {
    expectIdentifier('context item key', Key);
    delete Playground.Context[Key];
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index >= 0) {
        rerenderPlayground();
    }
}
/**** preserveContextItem ****/
function preserveContextItem(Key) {
    expectIdentifier('context item key', Key);
    localStorage.setItem(Key, '' + (Playground.Context[Key] || ''));
}
/**** restoreContextItem ****/
function restoreContextItem(Key) {
    expectIdentifier('context item key', Key);
    Playground.Context[Key] = localStorage.getItem(Key) || '';
}
//------------------------------------------------------------------------------
//--                              Playground UI                               --
//------------------------------------------------------------------------------
const PlaygroundUITypes = [
    'textline-input', 'password-input', 'number-input', 'url-input', 'text-input',
    'speech-input',
    'checkbox', 'radiobutton-group', 'dropdown', 'button',
    'textline-output', 'number-output', 'text-output', 'fineprint-output',
    'text', 'fineprint',
    'api-server-input',
];
const PlaygroundUIEventTypes = ['click', 'input'];
/**** showWorkspace ****/
function showWorkspace() {
    Playground.activeTab = 0;
    rerenderPlayground();
}
/**** showUI ****/
function showUI() {
    Playground.activeTab = 1;
    rerenderPlayground();
}
/**** UIElements ****/
function UIElements() {
    return Playground.UI.map((Item, i) => Item.Key);
}
/**** UIhasElement ****/
function UIhasElement(Key) {
    expectIdentifier('UI element key', Key);
    return Playground.UI.some((Item) => Item.Key === Key);
}
/**** clearUI ****/
function clearUI() {
    Playground.UI.length = 0;
    rerenderPlayground();
}
/**** enableUI ****/
function enableUI() {
    Playground.UIEnabling = true;
    rerenderPlayground();
}
/**** disableUI ****/
function disableUI() {
    Playground.UIEnabling = false;
    rerenderPlayground();
}
/**** appendToUI ****/
function appendToUI(Key, Label, Type, OptionSet = {}) {
    expectIdentifier('UI element key', Key);
    expectTextline('UI element label', Label);
    expectOneOf('UI element type', Type, PlaygroundUITypes);
    allowPlainObject('UI element option set', OptionSet);
    const oldIndex = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (oldIndex >= 0) {
        Playground.UI.splice(oldIndex, 1);
    }
    Playground.UI.push({ Key, Label, Type, OptionSet });
    rerenderPlayground();
}
/**** configureUI ****/
function configureUI(Key, Option, Value) {
    expectIdentifier('UI element key', Key);
    expectIdentifier('UI option name', Option);
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index < 0)
        throwError('NoSuchUIElement: no UI element named ' + quoted(Key) + ' found');
    Playground.UI[Index].OptionSet[Option] = Value;
    rerenderPlayground();
}
/**** ConfigurationOf ****/
function ConfigurationOf(Key, Option) {
    expectIdentifier('UI element key', Key);
    expectIdentifier('UI option name', Option);
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index < 0)
        throwError('NoSuchUIElement: no UI element named ' + quoted(Key) + ' found');
    return Playground.UI[Index].OptionSet[Option];
}
/**** EnablingOf ****/
function EnablingOf(Key) {
    expectIdentifier('UI element key', Key);
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index < 0)
        throwError('NoSuchUIElement: no UI element named ' + quoted(Key) + ' found');
    if (!Playground.UIEnabled) {
        return false;
    }
    const Candidate = Playground.UI[Index].OptionSet['Enabling'];
    return (ValueIsBoolean(Candidate) ? Candidate : true);
}
/**** setEnablingOf ****/
function setEnablingOf(Key, Enabling) {
    expectIdentifier('UI element key', Key);
    expectBoolean('enabling value', Enabling);
    configureUI(Key, 'Enabling', Enabling); // keeps code DRY
}
/**** enable/disable ****/
function enable(Key) {
    configureUI(Key, 'Enabling', true); // keeps code DRY
}
function disable(Key) {
    configureUI(Key, 'Enabling', false); // keeps code DRY
}
/**** clearChoicesOf ****/
function clearChoicesOf(Key) {
    expectIdentifier('UI element key', Key);
    configureUI(Key, 'Choices', ''); // keeps code DRY
}
/**** appendChoiceTo ****/
function appendChoiceTo(Key, Choice) {
    expectIdentifier('UI element key', Key);
    expectTextline('choice', Choice);
    let currentChoices = ConfigurationOf(Key, 'Choices');
    if (!ValueIsText(currentChoices)) {
        currentChoices = '';
    }
    configureUI(Key, 'Choices', (currentChoices + '\n' + Choice).trim());
}
/**** removeFromUI ****/
function removeFromUI(Key) {
    expectIdentifier('UI element key', Key);
    const Index = Playground.UI.findIndex((Item) => Item.Key === Key);
    if (Index >= 0) {
        Playground.UI.splice(Index, 1);
        rerenderPlayground();
    }
}
/**** clearConsole ****/
function clearConsole() {
    setInContext('Console', '');
    //  rerenderPlayground()
}
/**** print ****/
function print(Message) {
    Message = (Message == null ? '' : '' + Message);
    if (!UIhasElement('Console')) {
        appendToUI('Console', 'Console', 'text-output');
    }
    setInContext('Console', (getFromContext('Console') || '') + Message);
}
/**** println ****/
function println(Message) {
    Message = (Message == null ? '' : '' + Message);
    if (!UIhasElement('Console')) {
        appendToUI('Console', 'Console', 'text-output');
    }
    setInContext('Console', (getFromContext('Console') || '') + Message + '\n');
}
/**** logStep ****/
function logStep(Message) {
    expectText('log message', Message);
    if (getFromContext('logStepsToConsole') === 'true') {
        println('\n----\nnext Step: ' + Message + '\n----');
    }
}
/**** logAction ****/
function logAction(Message) {
    expectText('log message', Message);
    if ((getFromContext('logStepsToConsole') === 'true') &&
        (getFromContext('logActionsToConsole') === 'true')) {
        println(Message);
    }
}
/**** enqueueUIEvent ****/
function enqueueUIEvent(Type, Key) {
    if (Playground.UIEventHandlerState == null) {
        return;
    }
    if (Playground.UIEventHandlerState === 'waiting') {
        if (Playground.UIEventTimer != null) {
            clearTimeout(Playground.UIEventTimer);
            Playground.UIEventTimer = undefined;
        }
        Playground.currentUIEvent = { Type, Key };
        Playground.UIEventHandlerState = 'busy';
        const resolve = Playground.UIEventHandler;
        Playground.UIEventHandler = undefined;
        return resolve(true);
    }
    else {
        Playground.UIEventQueue.push({ Type, Key });
    }
}
/**** waitForNextUIEvent ****/
async function waitForNextUIEvent(Timeout) {
    expectNumber('timeout [s]', Timeout);
    Timeout = Math.round(Timeout * 1000);
    /*
        if (Playground.UIEventHandlerState != null) throwError(
          'InvalidState: nested event loop detected'
        )
    */
    Playground.currentUIEvent = undefined;
    Playground.UIEventHandlerState = 'waiting';
    return new Promise((resolve) => {
        if (Timeout === 0) {
            Playground.currentUIEvent = Playground.UIEventQueue.unshift();
            Playground.UIEventHandlerState = (Playground.currentUIEvent == null ? undefined : 'busy');
            return resolve(Playground.currentUIEvent != null);
        }
        Playground.UIEventHandler = resolve;
        if (Timeout > 0) {
            Playground.UIEventTimer = setTimeout(() => {
                if (Playground.UIEventHandler === resolve) {
                    Playground.UIEventHandler = undefined;
                    return resolve(false);
                }
            }, Timeout);
        }
    });
}
/**** currentUIEvent ****/
function currentUIEvent() {
    return Playground.currentUIEvent;
}
/**** clearPendingUIEvents ****/
function clearPendingUIEvents() {
    Playground.UIEventQueue.length = 0;
}
/**** ButtonWasClicked ****/
function ButtonWasClicked(Key) {
    const currentEvent = currentUIEvent();
    return ((currentEvent != null) &&
        (currentEvent.Type === 'click') && (currentEvent.Key === Key));
}
/**** InputWasChanged ****/
function InputWasChanged(Key) {
    const currentEvent = currentUIEvent();
    return ((currentEvent != null) &&
        (currentEvent.Type === 'input') && (currentEvent.Key === Key));
}
/**** leaveUIEventLoop ****/
function leaveUIEventLoop() {
    if (Playground.UIEventHandlerState === 'busy') {
        throw 'leaveUIEventLoop';
    }
    else {
        throwError('InvalidState: not within a running UI event handler');
    }
}
//------------------------------------------------------------------------------
//--                           Playground AI Basics                           --
//------------------------------------------------------------------------------
/**** ChatCompletionFor ****/
async function ChatCompletionFor(MessageList, OptionSet = {}) {
    expectListSatisfying('message list', MessageList, ValueIsString);
    expectPlainObject('option set', OptionSet);
    if (MessageList.length < 2)
        throwError('InvalidArgument: the given "MessageList" contains less than 2 elements');
    if (MessageList.length % 2 !== 0)
        throwError('InvalidArgument: the given "MessageList" contains an odd number of elements');
    let APIServer = (OptionSet.APIServer || getFromContext('APIServer') || '').trim();
    expectURL('APIServer', APIServer);
    let APIKey = (OptionSet.APIKey || getFromContext('APIKey') || '').trim();
    expectTextline('APIKey', APIKey);
    let Messages = [
        { role: 'system', content: MessageList[0] },
        { role: 'user', content: MessageList[1] }
    ];
    for (let i = 2, l = Messages.length; i < l; i += 2) {
        Messages.push({ role: 'assistant', content: MessageList[i] }, { role: 'user', content: MessageList[i + 1] });
    }
    const RequestBody = Object.assign({
        messages: Messages, temperature: 0, top_k: 1, seed: 12345,
        max_tokens: 200, stream: false
    }, OptionSet);
    if (RequestBody.model == null)
        throwError('Missingargument: no AI "model" given');
    RequestBody.num_predict = RequestBody.max_tokens;
    try {
        for (;;) {
            const Headers = {
                accept: 'application/json',
                'content-type': 'application/json',
            };
            if (APIKey.trim() !== '') {
                Headers.Authorization = `Bearer ${APIKey}`;
            }
            const Response = await fetch(APIServer, {
                method: 'POST',
                headers: Headers,
                body: JSON.stringify(RequestBody)
            });
            if (Response.ok) {
                const JSON = (await Response.json());
                if ('choices' in JSON) {
                    return JSON.choices[0].message.content;
                }
                else {
                    return JSON.message.content;
                }
            }
            if (Response.status === 429) {
                if (window.confirm('API Request Limit reached\n\nDo you want to continue? ' +
                    'Then wait a minute and press "Ok" - otherwise press "Cancel" ' +
                    'to abort the Blockly program') == true) {
                    continue;
                }
                else {
                    throw 'HTTP 439 (too many requests)';
                }
            }
            else {
                throwError('RequestFailed: API request failed with HTTP status ' + Response.status);
            }
        }
    }
    catch (Signal) {
        throwError('RequestFailure: API request failed with ' + Signal);
    }
}
/**** RequestOptionsFrom ****/
function RequestOptionsFrom(ContextPrefix = 'default_') {
    const Result = {};
    ('model temperature top_k top_p frequency_penalty presence_penalty ' +
        'max_tokens num_ctx return_citations return_images').split(' ').forEach((Option) => {
        const Candidate = (getFromContext(ContextPrefix + Option) ||
            getFromContext('default_' + Option));
        if (Candidate != null) {
            Result[Option] = Candidate;
        }
    });
    return Result;
}
//------------------------------------------------------------------------------
//--                         Playground AI Mezzanines                         --
//------------------------------------------------------------------------------
/**** SummaryOfText ****/
async function SummaryOfText(Text) {
    expectText('text to summarize', Text);
    const MessageList = [
        expectedText('system template for summarizer', getFromContext('Summarizer_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for summarizer', getFromContext('Summarizer_UserTemplate')).replace('{{TextToSummarize}}', Text),
    ];
    const OptionSet = RequestOptionsFrom('Summarizer_');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    return Response;
}
/**** ResearchFor ****/
async function ResearchFor(Objective) {
    expectText('objective', Objective);
    logStep('conducting web research to achieve ' + quoted(Objective));
    const SearchPhrase = await SearchPhraseForText(Objective);
    const Findings = [];
    logAction('(searching for ' + quoted(SearchPhrase) + ')');
    const URLList = await WebSearchFor(SearchPhrase);
    if (URLList.length === 0) {
        logAction('(no relevant documents found)');
    }
    else {
        logAction('(reading ' + URLList.length + ' document(s))');
        URLList.forEach((URL) => {
            logAction(' - ' + quoted(URL));
        });
    }
    for (const URL of URLList) {
        let Text;
        if (ValueIsWikipediaURL(URL)) {
            logAction('(fetching Wikipedia article ' + quoted(URL) + ')');
            Text = await TextOfWikipediaArticleForAI(URL);
        }
        else {
            logAction('(fetching Web document ' + quoted(URL) + ')');
            Text = await TextOfWebDocument(URL);
        }
        const Finding = await FindingsFromText(Text, Objective);
        if (await TextHelpsWith(Finding, Objective)) {
            Findings.push(Finding);
        }
    }
    if (Findings.length === 0) {
        return '';
    }
    else {
        let Result = Findings.shift() || '';
        while (Findings.length > 0) {
            Result = await SolutionMergedFromTexts(Result, Findings.shift() || '', Objective);
        }
        return JSON.stringify((await SolutionEncodedFrom(Result, Objective)) || '');
    }
}
/**** SearchPhraseForText ****/
async function SearchPhraseForText(Objective) {
    expectText('objective', Objective);
    const MessageList = [
        expectedText('system template for search phrase generator', getFromContext('SearchGenerator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for search phrase generator', getFromContext('SearchGenerator_UserTemplate')).replace('{{Objective}}', Objective),
    ];
    const OptionSet = RequestOptionsFrom('SearchGenerator_');
    logAction('(generating search phrase)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    Response = Response.trim();
    if (/^".*"$/.test(Response)) {
        Response = Response.slice(1, Response.length - 1);
    }
    return Response;
}
/**** FindingsFromText ****/
async function FindingsFromText(Text, Objective) {
    //  expectText('text to analyze',Text)
    expectText('objective', Objective);
    if (!ValueIsText(Text) || (Text.trim() === '')) {
        logAction('  (skipping empty or non-text document)');
        return '';
    }
    const MessageList = [
        expectedText('system template for information extractor', getFromContext('InformationExtractor_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for information extractor', getFromContext('InformationExtractor_UserTemplate')).replace('{{TextToRead}}', Text)
            .replace('{{Objective}}', Objective),
    ];
    const OptionSet = RequestOptionsFrom('InformationExtractor_');
    logAction('(extracting relevant information from text)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    return Response;
}
/**** TextHelpsWith ****/
async function TextHelpsWith(Text, Objective) {
    expectText('text to analyze', Text);
    expectText('objective', Objective);
    if (Text.trim() === '') {
        return false;
    } // ignore empty or invalid files
    const MessageList = [
        expectedText('system template for information validator', getFromContext('InformationValidator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for information validator', getFromContext('InformationValidator_UserTemplate')).replace('{{TextToAnalzye}}', Text)
            .replace('{{Objective}}', Objective),
    ];
    const OptionSet = RequestOptionsFrom('InformationValidator_');
    logAction('(validating relevance of findings)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    const Relevance = (Response.trim().toLowerCase() === 'true');
    if (Relevance == false) {
        logAction('  (ignoring irrelevant findings)');
    }
    return Relevance;
}
/**** SolutionMergedFromTexts ****/
async function SolutionMergedFromTexts(Text1, Text2, Objective) {
    expectText('text #1', Text1);
    expectText('text #2', Text2);
    expectText('objective', Objective);
    const MessageList = [
        expectedText('system template for solution merger', getFromContext('SolutionMerger_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for solution merger', getFromContext('SolutionMerger_UserTemplate')).replace('{{Text1}}', Text1)
            .replace('{{Text2}}', Text2)
            .replace('{{Objective}}', Objective),
    ];
    const OptionSet = RequestOptionsFrom('SolutionMerger_');
    logAction('(merging two findings)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    return Response;
}
/**** SolutionEncodedFrom ****/
async function SolutionEncodedFrom(Text, Objective) {
    expectText('text', Text);
    expectText('objective', Objective);
    const MessageList = [
        expectedText('system template for solution encoder', getFromContext('SolutionEncoder_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('system template for solution encoder', getFromContext('SolutionEncoder_UserTemplate')).replace('{{TextToAnalyze}}', Text)
            .replace('{{Objective}}', Objective),
    ];
    const OptionSet = RequestOptionsFrom('SolutionEncoder_');
    logAction('(generating machine-readable response)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    let JSONResponse = JSONinText(Response);
    return (ValueIsList(JSONResponse) ? JSONResponse : []);
}
/**** ComputationOf ****/
async function ComputationOf(Objective) {
    expectText('objective', Objective);
    logStep('using JavaScript to achieve ' + quoted(Objective));
    let Knowledge = undefined;
    try {
        let JSONKnowledge = '' + getFromContext('Knowledge');
        Knowledge = JSON.parse(JSONKnowledge);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsKnowledge(Knowledge)) {
        Knowledge = [];
    }
    const ParameterList = await ParameterListFor(Objective);
    console.log('ParameterList', ParameterList);
    let FunctionSource = await FunctionFor(Objective, ParameterList);
    console.log('FunctionSource', FunctionSource);
    let BlockCommentMatch = FunctionSource.match(/^\s*\/\*[\s\S]*\*\/\s*/);
    let afterBlockComment = (BlockCommentMatch == null ? 0 : BlockCommentMatch[0].length);
    if (FunctionSource.slice(afterBlockComment).startsWith('function')) {
        FunctionSource = (FunctionSource.slice(0, afterBlockComment) +
            'return ' +
            FunctionSource.slice(afterBlockComment));
    }
    else {
        throwError('FunctionGenerationError: could not generate executable function ' +
            '(unexpected source format)');
    }
    let compiledFunction;
    try {
        logAction('(compiling JavaScript function)');
        compiledFunction = new Function(FunctionSource);
    }
    catch (Signal) {
        throwError('CompilationError: could not generate executable function\n' +
            'reason: ' + Signal);
    }
    compiledFunction = compiledFunction();
    if (compiledFunction == null)
        throwError('FunctionGenerationError: could not create desired function');
    const ArgumentList = [];
    logAction('(generating argument list)');
    for (const Parameter of JSON.parse(ParameterList)) {
        const Argument = JSON.parse(Knowledge[Parameter.Index].Fact);
        ArgumentList.push(Argument);
    }
    console.log('ArgumentList', ArgumentList);
    try {
        logAction('(executing JavaScript function)');
        let Result = compiledFunction.apply(null, ArgumentList);
        console.log('computed Result', Result);
        if (Result == null) {
            Result = null;
        }
        return JSON.stringify(Result);
    }
    catch (Signal) {
        throwError('ExecutionError: could not execute generated function\n' +
            'reason: ' + Signal);
    }
    return ''; // just to satisfy the compiler
}
/**** ParameterListFor ****/
async function ParameterListFor(Objective) {
    expectText('objective', Objective);
    let Knowledge = undefined;
    try {
        let JSONKnowledge = '' + getFromContext('Knowledge');
        Knowledge = JSON.parse(JSONKnowledge);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsKnowledge(Knowledge)) {
        Knowledge = [];
    }
    const MessageList = [
        expectedText('system template for parameter list generator', getFromContext('ParameterListGenerator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for parameter list generator', getFromContext('ParameterListGenerator_UserTemplate')).replace('{{Objective}}', Objective)
            .replace('{{KnowledgeOverview}}', OverviewOfKnowledge(Knowledge)),
    ];
    const OptionSet = RequestOptionsFrom('ParameterListGenerator_');
    logAction('(generating parameter list)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    let ParameterList = JSONinText(Response);
    if (!ValueIsList(ParameterList)) {
        ParameterList = [];
    }
    else {
        ParameterList.forEach((Parameter) => {
            expectIntegerInRange('parameter fact index', Parameter.Index, 0, Knowledge.length - 1);
            expectIdentifier('parameter name', Parameter.Name);
            Parameter.Description = Knowledge[Parameter.Index].Description;
        });
    }
    return JSON.stringify(ParameterList);
}
/**** FunctionFor ****/
async function FunctionFor(Objective, JSONParameterList) {
    expectText('objective', Objective);
    expectText('JSON-encoded parameter list', JSONParameterList);
    let ParameterList = undefined;
    try {
        ParameterList = JSON.parse(JSONParameterList);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsParameterList(ParameterList))
        throwError('InvalidArgument: the given "ParameterList" argument does not ' +
            'contain a valid JSON-encoded function parameter list');
    const MessageList = [
        expectedText('system template for function generator', getFromContext('FunctionGenerator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('user template for function generator', getFromContext('FunctionGenerator_UserTemplate')).replace('{{Objective}}', Objective)
            .replace('{{ParameterList}}', ParameterList.map((Parameter) => Parameter.Name + ': ' + Parameter.Description).join('\n')),
    ];
    const OptionSet = RequestOptionsFrom('FunctionGenerator_');
    logAction('(generating function)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    if (/(^|\n)```javascript/.test(Response)) {
        Response = Response.replace(/^[\s\S]*```javascript\s*/, '')
            .replace(/```[\s\S]*$/, '');
    }
    return Response;
}
/**** StepsDerivedFromText ****/
async function StepsDerivedFromText(Task) {
    expectText('task to perform', Task);
    let Knowledge = undefined;
    try {
        let JSONKnowledge = '' + getFromContext('Knowledge');
        Knowledge = JSON.parse(JSONKnowledge);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsKnowledge(Knowledge)) {
        Knowledge = [];
    }
    const MessageList = [
        expectedText('system template for task decomposer', getFromContext('TaskDecomposer_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('system template for task decomposer', getFromContext('TaskDecomposer_UserTemplate')).replace('{{TaskDescription}}', Task)
            .replace('{{KnowledgeOverview}}', OverviewOfKnowledge(Knowledge)),
    ];
    const OptionSet = RequestOptionsFrom('TaskDecomposer_');
    logAction('(deriving the steps needed to perform the given task)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    const StepList = JSONinText(Response);
    if (ValueIsStepList(StepList)) {
        return StepList;
    }
    else {
        console.error('invalid list of steps', StepList);
        throwError('the LLM did not produce a valid step');
    }
}
/**** addKnowledgeFrom ****/
async function addKnowledgeFrom(Objective, Fact) {
    expectText('objective', Objective);
    expectText('fact', Fact);
    if (Fact.trim().length === 0) {
        return;
    }
    let Knowledge = undefined;
    try {
        let JSONKnowledge = '' + getFromContext('Knowledge');
        Knowledge = JSON.parse(JSONKnowledge);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsKnowledge(Knowledge)) {
        Knowledge = [];
    }
    const MessageList = [
        expectedText('system template for knowledge generator', getFromContext('KnowledgeGenerator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('system template for knowledge generator', getFromContext('KnowledgeGenerator_UserTemplate')).replace('{{Objective}}', Objective)
            .replace('{{Fact}}', Fact),
    ];
    const OptionSet = RequestOptionsFrom('KnowledgeGenerator_');
    logAction('(adds a new fact to the given knowledge)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    Knowledge.push({ Description: Response.trim(), Fact: Fact });
    setInContext('Knowledge', JSON.stringify(Knowledge));
    return;
}
/**** AnswerGeneratedFor ****/
async function AnswerGeneratedFor(Task) {
    expectText('task to perform', Task);
    let Knowledge = undefined;
    try {
        let JSONKnowledge = '' + getFromContext('Knowledge');
        Knowledge = JSON.parse(JSONKnowledge);
    }
    catch (Signal) { /* nop */ }
    if (!ValueIsKnowledge(Knowledge)) {
        Knowledge = [];
    }
    const MessageList = [
        expectedText('system template for answer generator', getFromContext('AnswerGenerator_SystemTemplate') ||
            getFromContext('default_SystemTemplate') ||
            'Be precise and concise.'),
        expectedText('system template for answer generator', getFromContext('AnswerGenerator_UserTemplate')).replace('{{Task}}', Task)
            .replace('{{Knowledge}}', JSON.stringify(Knowledge)),
    ];
    const OptionSet = RequestOptionsFrom('AnswerGenerator_');
    logAction('(generating response for the completed task)');
    let Response = await ChatCompletionFor(MessageList, OptionSet);
    return Response.trim();
}
//------------------------------------------------------------------------------
//--                           Playground AI Tools                            --
//------------------------------------------------------------------------------
/**** ValueIsKnowledge ****/
function ValueIsKnowledge(Value, JSONisAllowed = false) {
    try {
        if (JSONisAllowed && ValueIsString(Value)) {
            Value = JSON.parse(Value);
        }
        return ValueIsListSatisfying(Value, (Value) => (ValueIsPlainObject(Value) &&
            ValueIsNonEmptyString(Value.Description) &&
            ValueIsNonEmptyString(Value.Fact)));
    }
    catch (Signal) {
        return false;
    }
}
/**** OverviewOfKnowledge ****/
function OverviewOfKnowledge(Knowledge) {
    return (Knowledge.length === 0
        ? ''
        : Knowledge.map((Item, i) => i + ': ' + Item.Description).join('\n')); // yes, the output is 0-based
}
/**** ValueIsStep ****/
function ValueIsStep(Value) {
    return (ValueIsPlainObject(Value) &&
        ValueIsOneOf(Value.Tool, ['ResearchTool', 'ComputationTool', 'ResponseTool']) &&
        ValueIsNonEmptyString(Value.Objective) &&
        ValueIsNonEmptyString(Value.Justification));
}
/**** ValueIsStepList ****/
function ValueIsStepList(Value, JSONisAllowed = false) {
    try {
        if (JSONisAllowed && ValueIsString(Value)) {
            Value = JSON.parse(Value);
        }
        return ValueIsListSatisfying(Value, ValueIsStep);
    }
    catch (Signal) {
        return false;
    }
}
/**** ValueIsParameter ****/
function ValueIsParameter(Value) {
    return (ValueIsPlainObject(Value) &&
        ValueIsOrdinal(Value.Index) &&
        ValueIsNonEmptyString(Value.Name) &&
        ValueIsNonEmptyString(Value.Description));
}
/**** ValueIsParameterList ****/
function ValueIsParameterList(Value, JSONisAllowed = false) {
    try {
        if (JSONisAllowed && ValueIsString(Value)) {
            Value = JSON.parse(Value);
        }
        return ValueIsListSatisfying(Value, ValueIsParameter);
    }
    catch (Signal) {
        return false;
    }
}
/**** WebSearchFor ****/
async function WebSearchFor(SearchPhrase) {
    try {
        let URLList = await WebSearch(SearchPhrase);
        if (URLList.length > 10) {
            URLList.length = 10;
        }
        return URLList;
    }
    catch (Signal) {
        console.error('"WebSearchFor" failed with', Signal);
        throw Signal;
    }
}
/**** WebSearch - returns a list of URLs ****/
async function WebSearch(SearchPhrase) {
    const SearXNGServer = getFromContext('SearXNGServer');
    if (ValueIsURL(SearXNGServer)) { // then search using the API
        let SearXNGThreshold = parseFloat(getFromContext('SearXNGScoreThreshold') || '2');
        if (!ValueIsNumberInRange(SearXNGThreshold, 0, 10, true, true))
            throwError('InvalidContextItem: invalid "SearXNGScoreThreshold" context item found');
        const Parameters = new URLSearchParams({
            q: SearchPhrase, language: 'en',
            format: 'json', categories: 'general', num_results: '10'
        });
        const Response = await fetch(`${SearXNGServer}/search?${Parameters}`); // may fail!
        return (await Response.json()).results
            .filter((Result) => Result.score >= SearXNGThreshold)
            .map((Result) => Result.url);
    }
    else { // else search using the Web interface
        let SearXNGServers = [];
        const SearXNGServerList = getFromContext('SearXNGServerList') || '[]';
        try {
            const URLList = JSON.parse(SearXNGServerList);
            if (ValueIsListSatisfying(URLList, ValueIsURL)) {
                SearXNGServers = URLList;
            }
        }
        catch (Signal) { /* nop */ }
        if (SearXNGServers.length === 0) {
            const Response = await fetch('https://searx.space/data/instances.json');
            if (Response.ok) {
                const URLList = Object.keys((await Response.json()).instances)
                    .filter((Server) => !Server.endsWith('.onion/'));
                if (ValueIsListSatisfying(URLList, ValueIsURL)) {
                    SearXNGServers = URLList;
                }
            }
            else {
                throwError('NoSearXNGServers: searching for SearXNG servers failed with HTTP ' +
                    'status ' + Response.status);
            }
        }
        if (SearXNGServers.length === 0)
            throwError('NoSearXNGServers: could not find any public SearXNG servers');
        const Server = SearXNGServers[Math.trunc(Math.random() * SearXNGServers.length)];
        const Parameters = new URLSearchParams({
            q: SearchPhrase, language: 'en',
            format: 'html', categories: 'general', num_results: '10'
        });
        const Response = await fetch(`${Server}/search?${Parameters}`); // may fail!
        if (Response.ok) {
            const HTML = await Response.text();
            return Array.from(HTML.matchAll(/<h3><a href="([^"]+)"/g))
                .map((Match) => Match[1])
                .filter((URL) => (URL != null) && (URL.trim() !== ''));
        }
        else {
            throwError('WebSearchFailed: web search failed with HTTP status ' + Response.status);
        }
    }
}
/**** ValueIsWikipediaPageName ****/
function ValueIsWikipediaPageName(Value) {
    if (!ValueIsNonEmptyString(Value)) {
        return false;
    }
    Value = Value.trim();
    if ((Value[0].toUpperCase() !== Value[0]) ||
        /[#<>\[\]|{}_\x00-\x1F\x7F\uFFFD]|~~~|%[0-9a-f]{2}/i.test(Value) ||
        /^:|^\.\.?$|^\.?\.\/|\/\.\.?\/|\/\.\.?$/.test(Value) ||
        /&#?[a-zA-Z0-9]+;/.test(Value) // HTML character codes
    ) {
        return false;
    }
    Value = encodeURIComponent(Value.replace(/\s+/g, '_'));
    const UTF8Bytes = new TextEncoder().encode(Value);
    return (UTF8Bytes.length <= 255);
}
/**** ValueIsWikipediaURL ****/
const WikipediaPattern = /^http[s]?:\/\/[^.]+[.]wikipedia[.]org\/(?:wiki\/)?([^#?\/]+)/;
function ValueIsWikipediaURL(URL) {
    return WikipediaPattern.test(URL);
}
/**** TextOfWikipediaArticle ****/
async function TextOfWikipediaArticle(URL) {
    const PageName = URL.replace(/^.*\//, '')
        .replace(/#.*$/, '').replace(/[?].*$/, '');
    const RequestParameters = new URLSearchParams({
        action: 'parse',
        page: PageName,
        format: 'json',
        origin: '*'
    });
    let Data;
    try {
        const Response = await fetch(// may fail!
        `https://en.wikipedia.org/w/api.php?${RequestParameters}`);
        Data = await Response.json();
        if (Data.error != null) {
            return '';
        }
    }
    catch (Signal) { // don't worry about untrusted servers etc.
        console.error('failed to fetch ' + quoted(URL), Signal);
        return '';
    }
    const rawHTML = Data.parse.text['*'];
    const aux = document.createElement('div');
    aux.innerHTML = rawHTML;
    const unwantedSelectors = [
        'img', '.reference', '.infobox', '.navbox', '.metadata',
        '.mw-editsection', '.hatnote', '.reflist'
    ];
    unwantedSelectors.forEach((unwantedSelector) => {
        const unwantedElements = aux.querySelectorAll(unwantedSelector);
        unwantedElements.forEach((unwantedElement) => unwantedElement.remove());
    });
    aux.querySelectorAll('a').forEach((Element) => Element.removeAttribute('href'));
    const HTMLtoTextOptions = {
        wordwrap: 80,
        selectors: [
            { selector: 'h1', options: { uppercase: false } },
            { selector: 'h2', options: { uppercase: false } },
            { selector: 'h3', options: { uppercase: false } },
            { selector: 'h4', options: { uppercase: false } },
            { selector: 'h5', options: { uppercase: false } },
            { selector: 'h6', options: { uppercase: false } },
        ]
    };
    return HTMLtoText(aux.innerHTML, HTMLtoTextOptions);
}
/**** TextOfWikipediaArticleForAI ****/
async function TextOfWikipediaArticleForAI(URL) {
    let Text = await TextOfWikipediaArticle(URL);
    Text = TextWithoutSection(Text, 'See also');
    Text = TextWithoutSection(Text, 'References');
    Text = TextWithoutSection(Text, 'External Links');
    return Text;
}
function TextWithoutSection(Text, Heading) {
    let Pattern = new RegExp('(?:^|\\n\\n\\n)' + Heading + '(?:(?!(?:^|\\n{3}))[\\s\\S])*', 'i');
    return Text.replace(Pattern, '');
}
/**** TextOfWebDocument ****/
async function TextOfWebDocument(URL) {
    try {
        const Response = await fetch(URL, {
            headers: { 'Accept': 'text/*' }
        });
        const ContentType = Response.headers.get('content-type');
        if ((ContentType == null) || !ContentType.includes('text/')) {
            return '';
        }
        else {
            return HTMLtoText(await Response.text());
        }
    }
    catch (Signal) { // don't worry about untrusted servers etc.
        console.error('failed to fetch ' + quoted(URL), Signal);
        return '';
    }
}
/**** JSONinText ****/
function JSONinText(Text) {
    expectText('text', Text);
    function IndexOfClosingBracketAfter(StartIndex) {
        let Nesting = 1;
        let inString = (Text[StartIndex] === '"');
        let escaped = false;
        for (let i = StartIndex + 1, l = Text.length; i < l; i++) {
            if (escaped) {
                escaped = false;
                continue;
            }
            switch (Text[i]) {
                case '\\':
                    escaped = true;
                    break;
                case '"':
                    if (!escaped) {
                        inString = !inString;
                    }
                    ;
                    break;
                case '[':
                    if (!inString) {
                        Nesting++;
                    }
                    ;
                    break;
                case ']':
                    if (!inString) {
                        Nesting--;
                        if (Nesting === 0) {
                            return i;
                        }
                    }
                    ;
                    break;
                case '{':
                    if (!inString) {
                        Nesting++;
                    }
                    ;
                    break;
                case '}':
                    if (!inString) {
                        Nesting--;
                        if (Nesting === 0) {
                            return i;
                        }
                    }
                    ;
                    break;
            } // escaping '{','}','[' or ']' makes no sense and will crash JSON.parse below
        }
        return -1;
    }
    let firstBracketIndex = Text.indexOf('[');
    if (firstBracketIndex < 0) {
        firstBracketIndex = Text.length;
    }
    let firstBraceIndex = Text.indexOf('{');
    if (firstBraceIndex < 0) {
        firstBraceIndex = Text.length;
    }
    const JSONStart = Math.min(firstBracketIndex, firstBraceIndex);
    if (JSONStart === Text.length) {
        return undefined;
    }
    const JSONEnd = IndexOfClosingBracketAfter(JSONStart);
    if (JSONEnd < 0) {
        return undefined;
    }
    const JSONString = Text.slice(JSONStart, JSONEnd + 1);
    try {
        return JSON.parse(JSONString);
    }
    catch (Signal) {
        return undefined;
    }
}
/**** HTMLtoText ****/
function HTMLtoText(HTML, Options) {
    if (!ValueIsText(HTML)) {
        return '';
    } // simplifies handling of binary files
    if (Options == null) {
        Options = {
            wordwrap: 80,
            selectors: [
                { selector: 'h1', options: { uppercase: false } },
                { selector: 'h2', options: { uppercase: false } },
                { selector: 'h3', options: { uppercase: false } },
                { selector: 'h4', options: { uppercase: false } },
                { selector: 'h5', options: { uppercase: false } },
                { selector: 'h6', options: { uppercase: false } },
            ]
        };
    }
    return htmlToText(HTML, Options);
}
//------------------------------------------------------------------------------
//--                          Playground Miscellany                           --
//------------------------------------------------------------------------------
/**** rerenderPlayground ****/
function rerenderPlayground() {
    if (Playground.View != null) {
        Playground.View.rerender();
    }
}
//------------------------------------------------------------------------------
//--                              JS-Interpreter                              --
//------------------------------------------------------------------------------
const JSInterpreterStates = ['idle', 'running', 'suspended'];
/**** external API ****/
function externalAPI(Interpreter, global) {
    /**** PropertiesOfObject ****/
    Interpreter.setProperty(global, 'PropertiesOfObject', Interpreter.createNativeFunction(function _PropertiesOfObject(Target) {
        return Array.from(Object.keys(Playground.Interpreter.pseudoToNative(Target)));
    }));
    /**** ContextKeys ****/
    Interpreter.setProperty(global, 'ContextKeys', Interpreter.createNativeFunction(function _ContextKeys() {
        return ContextKeys();
    }));
    /**** clearContext ****/
    Interpreter.setProperty(global, 'clearContext', Interpreter.createNativeFunction(function _clearContext() {
        clearContext();
    }));
    /**** getFromContext ****/
    Interpreter.setProperty(global, 'getFromContext', Interpreter.createNativeFunction(function _getFromContext(Key) {
        return getFromContext(Key);
    }));
    /**** setInContext ****/
    Interpreter.setProperty(global, 'setInContext', Interpreter.createNativeFunction(function _setInContext(Key, Value) {
        setInContext(Key, ValueIsString(Value)
            ? Value
            : JSON.stringify(Playground.Interpreter.pseudoToNative(Value)));
    }));
    /**** removeFromContext ****/
    Interpreter.setProperty(global, 'removeFromContext', Interpreter.createNativeFunction(function _removeFromContext(Key) {
        removeFromContext(Key);
    }));
    /**** preserveContextItem ****/
    Interpreter.setProperty(global, 'preserveContextItem', Interpreter.createNativeFunction(function _preserveContextItem(Key) {
        preserveContextItem(Key);
    }));
    /**** restoreContextItem ****/
    Interpreter.setProperty(global, 'restoreContextItem', Interpreter.createNativeFunction(function _restoreContextItem(Key) {
        restoreContextItem(Key);
    }));
    /**** showWorkspace ****/
    Interpreter.setProperty(global, 'showWorkspace', Interpreter.createNativeFunction(function _showWorkspace() {
        showWorkspace();
    }));
    /**** showUI ****/
    Interpreter.setProperty(global, 'showUI', Interpreter.createNativeFunction(function _showUI() {
        showUI();
    }));
    /**** UIElements ****/
    Interpreter.setProperty(global, 'UIElements', Interpreter.createNativeFunction(function _UIElements() {
        return UIElements();
    }));
    /**** UIhasElement ****/
    Interpreter.setProperty(global, 'UIhasElement', Interpreter.createNativeFunction(function _UIhasElement(Key) {
        return UIhasElement(Key);
    }));
    /**** clearUI ****/
    Interpreter.setProperty(global, 'clearUI', Interpreter.createNativeFunction(function _clearUI() {
        clearUI();
    }));
    /**** enableUI ****/
    Interpreter.setProperty(global, 'enableUI', Interpreter.createNativeFunction(function _enableUI() {
        enableUI();
    }));
    /**** disableUI ****/
    Interpreter.setProperty(global, 'disableUI', Interpreter.createNativeFunction(function _disableUI() {
        disableUI();
    }));
    /**** appendToUI ****/
    Interpreter.setProperty(global, 'appendToUI', Interpreter.createNativeFunction(function _appendToUI(Key, Label, Type, OptionList = []) {
        appendToUI(Key, Label, Type, SetFromKeyValueList(OptionList));
    }));
    /**** appendTextlineInput ****/
    Interpreter.setProperty(global, 'appendTextlineInput', Interpreter.createNativeFunction(function _appendTextlineInput(Key, Label) {
        appendToUI(Key, Label, 'textline-input');
    }));
    /**** appendPasswordInput ****/
    Interpreter.setProperty(global, 'appendPasswordInput', Interpreter.createNativeFunction(function _appendPasswordInput(Key, Label) {
        appendToUI(Key, Label, 'password-input');
    }));
    /**** appendNumberInput ****/
    Interpreter.setProperty(global, 'appendNumberInput', Interpreter.createNativeFunction(function _appendNumberInput(Key, Label) {
        appendToUI(Key, Label, 'number-input');
    }));
    /**** appendURLInput ****/
    Interpreter.setProperty(global, 'appendURLInput', Interpreter.createNativeFunction(function _appendURLInput(Key, Label) {
        appendToUI(Key, Label, 'url-input');
    }));
    /**** appendTextInput ****/
    Interpreter.setProperty(global, 'appendTextInput', Interpreter.createNativeFunction(function _appendTextInput(Key, Label) {
        appendToUI(Key, Label, 'text-input');
    }));
    /**** appendSpeechInput ****/
    Interpreter.setProperty(global, 'appendSpeechInput', Interpreter.createNativeFunction(function _appendSpeechInput(Key, Label) {
        appendToUI(Key, Label, 'speech-input');
    }));
    /**** appendCheckbox ****/
    Interpreter.setProperty(global, 'appendCheckbox', Interpreter.createNativeFunction(function _appendCheckbox(Key, Label) {
        appendToUI(Key, Label, 'checkbox');
    }));
    /**** appendRadiobuttonGroup ****/
    Interpreter.setProperty(global, 'appendRadiobuttonGroup', Interpreter.createNativeFunction(function _appendRadiobuttonGroup(Key, Label) {
        appendToUI(Key, Label, 'radiobutton-group');
    }));
    /**** appendDropDown ****/
    Interpreter.setProperty(global, 'appendDropDown', Interpreter.createNativeFunction(function _appendDropDown(Key, Label) {
        appendToUI(Key, Label, 'dropdown');
    }));
    /**** appendButton ****/
    Interpreter.setProperty(global, 'appendButton', Interpreter.createNativeFunction(function _appendButton(Key, Label) {
        appendToUI(Key, Label, 'button');
    }));
    /**** appendTextlineOutput ****/
    Interpreter.setProperty(global, 'appendTextlineOutput', Interpreter.createNativeFunction(function _appendTextlineOutput(Key, Label) {
        appendToUI(Key, Label, 'textline-output', { readonly: true });
    }));
    /**** appendNumberOutput ****/
    Interpreter.setProperty(global, 'appendNumberOutput', Interpreter.createNativeFunction(function _appendNumberOutput(Key, Label) {
        appendToUI(Key, Label, 'number-output', { readonly: true });
    }));
    /**** appendTextOutput ****/
    Interpreter.setProperty(global, 'appendTextOutput', Interpreter.createNativeFunction(function _appendTextOutput(Key, Label) {
        appendToUI(Key, Label, 'text-output', { readonly: true });
    }));
    /**** appendFinePrintOutput ****/
    Interpreter.setProperty(global, 'appendFinePrintOutput', Interpreter.createNativeFunction(function _appendFinePrintOutput(Key, Label) {
        appendToUI(Key, Label, 'fineprint-output', { readonly: true });
    }));
    /**** appendText ****/
    Interpreter.setProperty(global, 'appendText', Interpreter.createNativeFunction(function _appendText(Key) {
        appendToUI(Key, '', 'text');
    }));
    /**** appendFinePrint ****/
    Interpreter.setProperty(global, 'appendFinePrint', Interpreter.createNativeFunction(function _appendFinePrint(Key) {
        appendToUI(Key, '', 'fineprint');
    }));
    /**** appendAPIServerInput ****/
    Interpreter.setProperty(global, 'appendAPIServerInput', Interpreter.createNativeFunction(function _appendAPIServerInput(Label) {
        appendToUI('APIServer', Label, 'api-server-input');
    }));
    /**** configureUI ****/
    Interpreter.setProperty(global, 'configureUI', Interpreter.createNativeFunction(function _configureUI(Key, Option, Value) {
        configureUI(Key, Option, Value);
    }));
    /**** ConfigurationOf ****/
    Interpreter.setProperty(global, 'ConfigurationOf', Interpreter.createNativeFunction(function _ConfigurationOf(Key, Option) {
        return ConfigurationOf(Key, Option);
    }));
    /**** EnablingOf ****/
    Interpreter.setProperty(global, 'EnablingOf', Interpreter.createNativeFunction(function _EnablingOf(Key) {
        return EnablingOf(Key);
    }));
    /**** setEnablingOf ****/
    Interpreter.setProperty(global, 'setEnablingOf', Interpreter.createNativeFunction(function _setEnablingOf(Key, Value) {
        setEnablingOf(Key, Value);
    }));
    /**** enable/disable ****/
    Interpreter.setProperty(global, 'enable', Interpreter.createNativeFunction(function _enable(Key) {
        enable(Key);
    }));
    Interpreter.setProperty(global, 'disable', Interpreter.createNativeFunction(function _disable(Key) {
        disable(Key);
    }));
    /**** isEnabled ****/
    Interpreter.setProperty(global, 'isEnabled', Interpreter.createNativeFunction(function _isEnabled(Key) {
        return (EnablingOf(Key) === true);
    }));
    /**** clearChoicesOf ****/
    Interpreter.setProperty(global, 'clearChoicesOf', Interpreter.createNativeFunction(function _clearChoicesOf(Key) {
        clearChoicesOf(Key);
    }));
    /**** appendChoiceTo ****/
    Interpreter.setProperty(global, 'appendChoiceTo', Interpreter.createNativeFunction(function _appendChoiceTo(Key, Choice) {
        appendChoiceTo(Key, Choice);
    }));
    /**** removeFromUI ****/
    Interpreter.setProperty(global, 'removeFromUI', Interpreter.createNativeFunction(function _removeFromUI(Key) {
        removeFromUI(Key);
    }));
    /**** clearConsole ****/
    Interpreter.setProperty(global, 'clearConsole', Interpreter.createNativeFunction(function _clearConsole() {
        clearConsole();
    }));
    /**** print ****/
    Interpreter.setProperty(global, 'print', Interpreter.createNativeFunction(function _print(Message) {
        print(ValueIsPlainObject(Message) || ValueIsList(Message)
            ? JSON.stringify(Message, null, ' ')
            : Message);
    }));
    /**** println ****/
    Interpreter.setProperty(global, 'println', Interpreter.createNativeFunction(function _println(Message) {
        println(ValueIsPlainObject(Message) || ValueIsList(Message)
            ? JSON.stringify(Message, null, ' ')
            : Message);
    }));
    /**** waitForNextUIEvent ****/
    Interpreter.setProperty(global, 'waitForNextUIEvent', Interpreter.createAsyncFunction(async function _waitForNextUIEvent(Timeout, Callback) {
        try {
            let EventReceived = await waitForNextUIEvent(Timeout);
            Callback(EventReceived);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** UIEventHandlerWasLeft ****/
    Interpreter.setProperty(global, 'UIEventHandlerWasLeft', Interpreter.createNativeFunction(function _UIEventHandlerWasLeft() {
        Playground.UIEventHandlerState = undefined;
    }));
    /**** clearPendingUIEvents ****/
    Interpreter.setProperty(global, 'clearPendingUIEvents', Interpreter.createNativeFunction(function _clearPendingUIEvents() {
        clearPendingUIEvents();
    }));
    /**** ButtonWasClicked ****/
    Interpreter.setProperty(global, 'ButtonWasClicked', Interpreter.createNativeFunction(function _ButtonWasClicked(Key) {
        return ButtonWasClicked(Key);
    }));
    /**** InputWasChanged ****/
    Interpreter.setProperty(global, 'InputWasChanged', Interpreter.createNativeFunction(function _InputWasChanged(Key) {
        return InputWasChanged(Key);
    }));
    /**** leaveUIEventLoop ****/
    Interpreter.setProperty(global, 'leaveUIEventLoop', Interpreter.createNativeFunction(function _leaveUIEventLoop() {
        leaveUIEventLoop();
    }));
    /**** ChatCompletionFor ****/
    Interpreter.setProperty(global, 'ChatCompletionFor', Interpreter.createAsyncFunction(async function _ChatCompletionFor(MessageList, OptionPrefix, Callback) {
        MessageList = Playground.Interpreter.pseudoToNative(MessageList);
        try {
            allowIdentifier('option prefix', OptionPrefix);
            const OptionSet = Object.assign(RequestOptionsFrom(OptionPrefix || 'default_'), { temperature: 0, top_k: 1, max_tokens: 200, stream: false });
            let Response = await ChatCompletionFor(MessageList, OptionSet);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** TextCompletionFor ****/
    Interpreter.setProperty(global, 'TextCompletionFor', Interpreter.createAsyncFunction(async function _TextCompletionFor(Prompt, OptionPrefix, Callback) {
        try {
            expectText('prompt', Prompt);
            allowIdentifier('option prefix', OptionPrefix);
            const MessageList = [
                acceptableText(getFromContext((OptionPrefix || 'default_') + 'SystemTemplate') ||
                    getFromContext('default_SystemTemplate'), 'Be precise and concise.'),
                acceptableText(getFromContext((OptionPrefix || 'default_') + 'UserTemplate') ||
                    getFromContext('default_UserTemplate'), '{{Prompt}}').replace('{{Prompt}}', Prompt),
            ];
            const OptionSet = Object.assign(RequestOptionsFrom(OptionPrefix || 'default_'), { temperature: 0, top_k: 1, max_tokens: 200, stream: false });
            let Response = await ChatCompletionFor(MessageList, OptionSet);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** SummaryOfText ****/
    Interpreter.setProperty(global, 'SummaryOfText', Interpreter.createAsyncFunction(async function _SummaryOfText(Text, Callback) {
        try {
            let Response = await SummaryOfText(Text);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** ResearchFor ****/
    Interpreter.setProperty(global, 'ResearchFor', Interpreter.createAsyncFunction(async function _ResearchFor(Objective, Callback) {
        try {
            let Response = await ResearchFor(Objective);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** SearchPhraseForText ****/
    Interpreter.setProperty(global, 'SearchPhraseForText', Interpreter.createAsyncFunction(async function _SearchPhraseForText(Objective, Callback) {
        try {
            let Response = await SearchPhraseForText(Objective);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** FindingsFromText ****/
    Interpreter.setProperty(global, 'FindingsFromText', Interpreter.createAsyncFunction(async function _FindingsFromText(Text, Objective, Callback) {
        try {
            let Response = await FindingsFromText(Text, Objective);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** TextHelpsWith ****/
    Interpreter.setProperty(global, 'TextHelpsWith', Interpreter.createAsyncFunction(async function _TextHelpsWith(Text, Objective, Callback) {
        try {
            let Response = await TextHelpsWith(Text, Objective);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** SolutionMergedFromTexts ****/
    Interpreter.setProperty(global, 'SolutionMergedFromTexts', Interpreter.createAsyncFunction(async function _SolutionMergedFromTexts(Text1, Text2, Objective, Callback) {
        try {
            let Response = await SolutionMergedFromTexts(Text1, Text2, Objective);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** SolutionEncodedFrom ****/
    Interpreter.setProperty(global, 'SolutionEncodedFrom', Interpreter.createAsyncFunction(async function _SolutionEncodedFrom(Text, Objective, Callback) {
        try {
            let Response = await SolutionEncodedFrom(Text, Objective);
            Callback(Playground.Interpreter.nativeToPseudo(Response));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** ComputationOf ****/
    Interpreter.setProperty(global, 'ComputationOf', Interpreter.createAsyncFunction(async function _ComputationOf(Objective, Callback) {
        try {
            let Response = await ComputationOf(Objective); // JSON value
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** ParameterListFor ****/
    Interpreter.setProperty(global, 'ParameterListFor', Interpreter.createAsyncFunction(async function _ParameterListFor(Objective, Callback) {
        try {
            let Response = await ParameterListFor(Objective); // JSON array
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** FunctionFor ****/
    Interpreter.setProperty(global, 'FunctionFor', Interpreter.createAsyncFunction(async function _FunctionFor(Objective, ParameterList, Callback) {
        try {
            let Response = await FunctionFor(Objective, ParameterList);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** StepsDerivedFromText ****/
    Interpreter.setProperty(global, 'StepsDerivedFromText', Interpreter.createAsyncFunction(async function _StepsDerivedFromText(Task, Callback) {
        try {
            let Response = await StepsDerivedFromText(Task);
            Callback(Playground.Interpreter.nativeToPseudo(Response));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** addKnowledgeFrom ****/
    Interpreter.setProperty(global, 'addKnowledgeFrom', Interpreter.createAsyncFunction(async function _addKnowledgeFrom(Objective, Fact, Callback) {
        try {
            await addKnowledgeFrom(Objective, Fact);
            Callback(undefined);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** AnswerGeneratedFor ****/
    Interpreter.setProperty(global, 'AnswerGeneratedFor', Interpreter.createAsyncFunction(async function _AnswerGeneratedFor(Task, Callback) {
        try {
            let Response = await AnswerGeneratedFor(Task);
            Callback(Response);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** ValueIsKnowledge ****/
    Interpreter.setProperty(global, 'ValueIsKnowledge', Interpreter.createNativeFunction(function _ValueIsKnowledge(Value, JSONisAllowed) {
        return ValueIsKnowledge(Value, JSONisAllowed);
    }));
    /**** ValueIsStep ****/
    Interpreter.setProperty(global, 'ValueIsStep', Interpreter.createNativeFunction(function _ValueIsStep(Value) {
        return ValueIsStep(Value);
    }));
    /**** ValueIsStepList ****/
    Interpreter.setProperty(global, 'ValueIsStepList', Interpreter.createNativeFunction(function _ValueIsStepList(Value, JSONisAllowed) {
        return ValueIsStepList(Value, JSONisAllowed);
    }));
    /**** ValueIsParameter ****/
    Interpreter.setProperty(global, 'ValueIsParameter', Interpreter.createNativeFunction(function _ValueIsParameter(Value) {
        return ValueIsParameter(Value);
    }));
    /**** ValueIsParameterList ****/
    Interpreter.setProperty(global, 'ValueIsParameterList', Interpreter.createNativeFunction(function _ValueIsParameterList(Value, JSONisAllowed) {
        return ValueIsParameterList(Value, JSONisAllowed);
    }));
    /**** ValueIsWikipediaURL ****/
    Interpreter.setProperty(global, 'ValueIsWikipediaURL', Interpreter.createNativeFunction(function _ValueIsWikipediaURL(Value) {
        return (ValueIsURL(Value) &&
            /http[s]?:\/\/[^\/]+[.]wikipedia[.]org\/[^\/]+/i.test(Value));
    }));
    /**** ValueIsWikipediaPageName ****/
    Interpreter.setProperty(global, 'ValueIsWikipediaPageName', Interpreter.createNativeFunction(function _ValueIsWikipediaPageName(Value) {
        return ValueIsWikipediaPageName(Value);
    }));
    /**** JSONinText ****/
    Interpreter.setProperty(global, 'JSONinText', Interpreter.createNativeFunction(function _JSONinText(Text) {
        return Playground.Interpreter.nativeToPseudo(JSONinText(Text));
    }));
    /**** HTMLtoText ****/
    Interpreter.setProperty(global, 'HTMLtoText', Interpreter.createNativeFunction(function _HTMLtoText(HTML) {
        return HTMLtoText(HTML);
    }));
    /**** TextOfWebDocument ****/
    Interpreter.setProperty(global, 'TextOfWebDocument', Interpreter.createAsyncFunction(async function _TextOfWebDocument(URL, Callback) {
        try {
            expectURL('document URL', URL);
            Callback(await TextOfWebDocument(URL));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** TextOfWikipediaArticle ****/
    Interpreter.setProperty(global, 'TextOfWikipediaArticle', Interpreter.createAsyncFunction(async function _TextOfWikipediaArticle(PageName, Callback) {
        try {
            if (!ValueIsWikipediaPageName(PageName))
                throwError('InvalidArgument: the given argument is no Wikipedia page name');
            Callback(await TextOfWikipediaArticle('https://en.wikipedia.org/' + PageName));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** WebSearch ****/
    Interpreter.setProperty(global, 'WebSearch', Interpreter.createAsyncFunction(async function _WebSearch(SearchPhrase, Callback) {
        try {
            expectNonEmptyString('search phrase', SearchPhrase);
            const Result = (await WebSearchFor(SearchPhrase))
                .filter((URL) => URL.startsWith('https://'));
            Callback(Playground.Interpreter.nativeToPseudo(Result));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** WikipediaSearch ****/
    Interpreter.setProperty(global, 'WikipediaSearch', Interpreter.createAsyncFunction(async function _WikipediaSearch(SearchPhrase, Callback) {
        try {
            expectNonEmptyString('Wikipedia search phrase', SearchPhrase);
            const Response = await fetch(// may fail!
            'https://en.wikipedia.org/w/api.php?action=query&list=search&srsearch=' +
                encodeURIComponent(SearchPhrase) +
                '&format=json&srlimit=20&inprop=url&origin=*');
            const TitleList = (await Response.json()).query.search.map((SearchResult) => SearchResult.title);
            Callback(Playground.Interpreter.nativeToPseudo(TitleList));
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** wait ****/
    Interpreter.setProperty(global, 'wait', Interpreter.createAsyncFunction(async function wait(Duration, Callback) {
        try {
            expectOrdinal('Duration', Duration);
            setTimeout(Callback, Duration);
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** alert ****/
    Interpreter.setProperty(global, 'alert', Interpreter.createNativeFunction(function alert(Message) {
        window.alert(Message);
    }));
    /**** confirm ****/
    Interpreter.setProperty(global, 'confirm', Interpreter.createNativeFunction(function confirm(Message) {
        return window.confirm(Message);
    }));
    /**** prompt ****/
    Interpreter.setProperty(global, 'prompt', Interpreter.createNativeFunction(function prompt(Message, Default) {
        return (window.prompt(Message, Default) || '');
    }));
    /**** speak ****/
    Interpreter.setProperty(global, 'speak', Interpreter.createAsyncFunction(async function _speak(Message, Callback) {
        try {
            expectNonEmptyString('message', Message);
            return new Promise((resolve, reject) => {
                const Utterance = new SpeechSynthesisUtterance(Message.trim());
                Utterance.lang = 'en';
                //              Utterance.pitch = ...
                //              Utterance.rate  = ...
                Utterance.onend = () => resolve(undefined);
                Utterance.onerror = () => reject();
                window.speechSynthesis.speak(Utterance);
            }).then(() => Callback()).catch(() => Callback());
        }
        catch (Signal) {
            Playground.thrownException = Signal;
            Callback(null);
        }
    }));
    /**** ValueIsNotEmpty ****/
    Interpreter.setProperty(global, 'ValueIsNotEmpty', Interpreter.createNativeFunction(function _ValueIsNotEmpty(Value) {
        return ValueIsNonEmptyString(Value);
    }));
    /**** ValueIsNumber ****/
    Interpreter.setProperty(global, 'ValueIsNumber', Interpreter.createNativeFunction(function _ValueIsNumber(Value) {
        return ValueIsNumber(Value);
    }));
    /**** ValueIsNumberInRange ****/
    Interpreter.setProperty(global, 'ValueIsNumberInRange', Interpreter.createNativeFunction(function _ValueIsNumberInRange(Value, Minimum, Maximum, withMinimum, withMaximum) {
        return ValueIsNumberInRange(Value, Minimum, Maximum, withMinimum, withMaximum);
    }));
    /**** ValueIsInteger ****/
    Interpreter.setProperty(global, 'ValueIsInteger', Interpreter.createNativeFunction(function _ValueIsInteger(Value) {
        return ValueIsInteger(Value);
    }));
    /**** ValueIsIntegerInRange ****/
    Interpreter.setProperty(global, 'ValueIsIntegerInRange', Interpreter.createNativeFunction(function _ValueIsIntegerInRange(Value, Minimum, Maximum) {
        return ValueIsIntegerInRange(Value, Minimum, Maximum);
    }));
    /**** ValueIsOrdinal ****/
    Interpreter.setProperty(global, 'ValueIsOrdinal', Interpreter.createNativeFunction(function _ValueIsOrdinal(Value) {
        return ValueIsOrdinal(Value);
    }));
    /**** ValueIsCardinal ****/
    Interpreter.setProperty(global, 'ValueIsCardinal', Interpreter.createNativeFunction(function _ValueIsCardinal(Value) {
        return ValueIsCardinal(Value);
    }));
    /**** ValueIsStringMatching ****/
    Interpreter.setProperty(global, 'ValueIsStringMatching', Interpreter.createNativeFunction(function _ValueIsStringMatching(Value, Pattern) {
        expectNonEmptyString('RegExp pattern', Pattern);
        return ValueIsStringMatching(Value, new RegExp(Pattern));
    }));
    /**** ValueIsURL ****/
    Interpreter.setProperty(global, 'ValueIsURL', Interpreter.createNativeFunction(function _ValueIsURL(Value) {
        return ValueIsURL(Value);
    }));
}
/**** startBlocklyProgram ****/
function startBlocklyProgram() {
    if (Playground.InterpreterState !== 'idle') {
        return;
    }
    let Code = javascriptGenerator.workspaceToCode(Playground.Workspace);
    try {
        Playground.Interpreter = new Interpreter(Code, externalAPI);
    }
    catch (Signal) {
        console.error('Blockly Code Generation Error', Signal);
        window.alert('Blockly Code Generation Error\n\n' + Signal);
    }
    clearContext();
    clearUI();
    enableUI();
    Object.assign(Playground.Context, {
        APIServer: undefined, APIKey: undefined,
        SearXNGServer: '', SearXNGScoreThreshold: 2,
        default_model: undefined, default_max_tokens: 2048, default_num_ctx: undefined,
        default_temperature: 0, default_top_p: undefined, default_top_k: 1,
        default_presence_penalty: undefined, default_frequency_penalty: 1,
        default_SystemTemplate: 'Be precise and concise.',
        default_UserTemplate: '{{Prompt}}',
        Summarizer_model: undefined, Summarizer_max_tokens: 1024,
        Summarizer_temperature: 0, Summarizer_top_p: undefined, Summarizer_top_k: 1,
        Summarizer_presence_penalty: undefined, Summarizer_frequency_penalty: 1,
        Summarizer_SystemTemplate: 'Be precise and concise.',
        Summarizer_UserTemplate: `
Your task is to provide a concise and precise summary of the following text,
capturing its key points and main ideas. The summary should be clear, accurate,
and significantly shorter than the original text.

Text to summarize:
{{TextToSummarize}}.

Please provide a concise summary of the above text in no more than 3-4 sentences.
`,
        TaskDecomposer_model: undefined, TaskDecomposer_max_tokens: 2048,
        TaskDecomposer_temperature: 0, TaskDecomposer_top_p: undefined, TaskDecomposer_top_k: 1,
        TaskDecomposer_presence_penalty: undefined, TaskDecomposer_frequency_penalty: 1,
        TaskDecomposer_SystemTemplate: 'Be precise and concise.',
        TaskDecomposer_UserTemplate: `
You are an AI assistant trained to perform a given task. Your role is to analyze
the already available information and use that as the starting point to break
down the following task into clear, logical, and sequential steps taking into
account the tools you have at hand:

Task Description:
{{TaskDescription}}.

Already available informations:
{{KnowledgeOverview}}

The available tools are:

1. ResponseTool:
   - Description: Generates a final response and completes the task. This must be the final step.
   - Usage: ResponseTool()

2. ResearchTool:
   - Description: Performs web searches to gather missing information and returns relevant results.
   - Usage: ResearchTool(objective)

3. ComputationTool:
   - Description: Performs any kind of computation to achieve an objective.
   - Usage: ComputationTool(objective)

Provide a detailed step-by-step breakdown of how to accomplish this task. Your
response should be in the form of a valid JSON list, where each item in the list
is an object containing the following properties:

- "Tool": "Name of the selected tool (ResearchTool, ComputationTool or ResponseTool)",
- "Objective": "A clear, concise statement of what the tool should achieve",
- "Justification": "A brief explanation of why this tool and objective were chosen"

Do not include any text outside of the JSON structure. The JSON should start
with an opening square bracket '[' and end with a closing square bracket ']'.
Each object within the list should be separated by a comma.

Example format:
[
  {
    "Tool":          "Chosen tool here",
    "Objective":     "Step objective here",
    "Justification": "A detailed justification here"
  },
  {
    "Tool":          "Another chosen tool here",
    "Objective":     "Another step objective",
    "Justification": "Another detailed justification"
  }
]

Ensure that your steps are
- comprehensive and cover all aspects of the task
- presented in a logical order
- clear and easy to understand for someone unfamiliar with the task
- specific and actionable

Avoid unnecessary steps. Use the already available information as your
starting point. End your list with a step using the ResponseTool.

Your goal is to create a guide that anyone could follow to successfully complete
the given task, presented in a valid JSON format.
`,
        SearchGenerator_model: undefined, SearchGenerator_max_tokens: 2048,
        SearchGenerator_temperature: 0, SearchGenerator_top_p: undefined, SearchGenerator_top_k: 1,
        SearchGenerator_presence_penalty: undefined, SearchGenerator_frequency_penalty: 1,
        SearchGenerator_SystemTemplate: 'Be precise and concise.',
        SearchGenerator_UserTemplate: `
You are an AI assistant tasked with formulating effective search engine queries.
Your goal is to create a concise, relevant query that will help find information
about the following problem:

{{Objective}}.

Generate a search query that:
1. Captures the core elements of the problem
2. Uses relevant keywords and phrases
3. Is concise (ideally 5-7 words)
4. Avoids unnecessary words or punctuation
5. Is likely to return useful results from a search engine

Important: Output ONLY the query string itself, without any additional text,
explanations, or formatting.
`,
        InformationExtractor_model: undefined, InformationExtractor_max_tokens: 2048,
        InformationExtractor_temperature: 0, InformationExtractor_top_p: undefined, InformationExtractor_top_k: 1,
        InformationExtractor_presence_penalty: undefined, InformationExtractor_frequency_penalty: 1,
        InformationExtractor_SystemTemplate: 'Be precise and concise.',
        InformationExtractor_UserTemplate: `
Your task is to answer the following question based ONLY on the information
provided in the given text. Do not use any external knowledge or information
beyond what is explicitly stated in the text.

Text:
{{TextToRead}}.

Question:
{{Objective}}.

Remember to answer the question from the given text only. Avoid anything that
is not part of the given text.

Answer:
`,
        InformationValidator_model: undefined, InformationValidator_max_tokens: 2048,
        InformationValidator_temperature: 0, InformationValidator_top_p: undefined, InformationValidator_top_k: 1,
        InformationValidator_presence_penalty: undefined, InformationValidator_frequency_penalty: 1,
        InformationValidator_SystemTemplate: 'Be precise and concise.',
        InformationValidator_UserTemplate: `
You are an expert at analyzing text for relevance to specific problems. Your
task is to determine whether a given text contains information that could help
solve a particular problem.

Text to analyze:
{{TextToAnalzye}}.

Problem to solve:
{{Objective}}.

Carefully examine the text and consider whether it contains any information,
concepts, ideas, or insights that could be useful in addressing or solving the
specified problem. Your response should be either "true" or "false".

Output "true" if the text contains any relevant information that could
contribute to solving the problem, even if it's not a complete solution.
Output "false" if the text does not contain any information that would be
helpful in addressing the problem.

Your response should be only one word: either "true" or "false".

Response:
`,
        SolutionMerger_model: undefined, SolutionMerger_max_tokens: 2048,
        SolutionMerger_temperature: 0, SolutionMerger_top_p: undefined, SolutionMerger_top_k: 1,
        SolutionMerger_presence_penalty: undefined, SolutionMerger_frequency_penalty: 1,
        SolutionMerger_SystemTemplate: 'Be precise and concise.',
        SolutionMerger_UserTemplate: `
**Task:** Merge two texts.

**Instructions:**

Combine the information from **Text 1** and **Text 2** into a single, cohesive
text that addresses the **Objective**. Output only the merged text, without any
additional content.

### Inputs:
- **Text 1:** {{Text1}}.
- **Text 2:** {{Text2}}.
- **Objective:** {{Objective}}.

### Output:
`,
        SolutionEncoder_model: undefined, SolutionEncoder_max_tokens: 2048,
        SolutionEncoder_temperature: 0, SolutionEncoder_top_p: undefined, SolutionEncoder_top_k: 1,
        SolutionEncoder_presence_penalty: undefined, SolutionEncoder_frequency_penalty: 1,
        SolutionEncoder_SystemTemplate: 'Be precise and concise.',
        SolutionEncoder_UserTemplate: `
Generate a concise, machine-processable solution for a given problem solely
based on the information in a given text. Output only the solution as a
JSON-compliant list, without any explanations or additional context.

Text to analyze:
{{TextToAnalyze}}.

Problem to solve:
{{Objective}}.

Response format:
Output a JSON array in the form: ["item1", "item2", "item3"]
Ensure that all string values are properly escaped according to JSON rules,
and that the entire output is valid JSON.
`,
        ParameterListGenerator_model: undefined, ParameterListGenerator_max_tokens: 2048,
        ParameterListGenerator_temperature: 0, ParameterListGenerator_top_p: undefined, ParameterListGenerator_top_k: 1,
        ParameterListGenerator_presence_penalty: undefined, ParameterListGenerator_frequency_penalty: 1,
        ParameterListGenerator_SystemTemplate: 'Be precise and concise.',
        ParameterListGenerator_UserTemplate: `
Use the following list of already available informations and decide which of
them could be used to achieve the given objective by running a Javascript
function with the chosen informations as its arguments.

Already available informations:
{{KnowledgeOverview}}.

Now use the chosen informations and construct a parameter list in JSON format where
each element is an object containing the following fields:

- "Index": the index of the chosen item from the list of informations
- "Name": a valid JavaScript function parameter name for the chosen information

Here is an example JSON list for a function that calculates the area of a
rectangle:
[
  { "Index":0, "Name":"width" },
  { "Index":1, "Name":"height" }
]

Please generate a similar JSON list for a function that achieves the following
objective

{{Objective}}.
`,
        FunctionGenerator_model: undefined, FunctionGenerator_max_tokens: 2048,
        FunctionGenerator_temperature: 0, FunctionGenerator_top_p: undefined, FunctionGenerator_top_k: 1,
        FunctionGenerator_presence_penalty: undefined, FunctionGenerator_frequency_penalty: 1,
        FunctionGenerator_SystemTemplate: 'Be precise and concise.',
        FunctionGenerator_UserTemplate: `
You are a highly skilled JavaScript developer. Your task is to generate a
JavaScript function that computes a specific result based on a given objective
and a list of arguments. Each argument is described by its name and the type of
data it will contain. Ensure that the function is well-documented with comments
explaining each step.

The objective:
{{Objective}}.

The list of arguments:
{{ParameterList}}

Output the generated function only. Avoid any "example usage", "module.exports"
or "export" statements or any other text outside the actual function.
`,
        KnowledgeGenerator_model: undefined, KnowledgeGenerator_max_tokens: 2048,
        KnowledgeGenerator_temperature: 0, KnowledgeGenerator_top_p: undefined, KnowledgeGenerator_top_k: 1,
        KnowledgeGenerator_presence_penalty: undefined, KnowledgeGenerator_frequency_penalty: 1,
        KnowledgeGenerator_SystemTemplate: 'Be precise and concise.',
        KnowledgeGenerator_UserTemplate: `
Generate a brief and concise headline (1 line, 50 words max) for the
following fact that was gathered in order to achieve the given objective:

Fact:
{{Fact}}.

Objective:
{{Objective}}.

Focus on the key points that are most relevant to the stated objective. Use
clear and simple language. Do not include any extraneous details.
`,
        AnswerGenerator_model: undefined, AnswerGenerator_max_tokens: 2048,
        AnswerGenerator_temperature: 0, AnswerGenerator_top_p: undefined, AnswerGenerator_top_k: 1,
        AnswerGenerator_presence_penalty: undefined, AnswerGenerator_frequency_penalty: 1,
        AnswerGenerator_SystemTemplate: 'Be precise and concise.',
        AnswerGenerator_UserTemplate: `
Given a specific task and all known facts, generate a brief and concise
human-readable result.

Task:
{{Task}}.

Known facts:
{{Knowledge}}

Focus on clarity and brevity.
`,
        Console: '',
        logStepsToConsole: true, logActionsToConsole: true,
    });
    Playground.InterpreterState = 'running';
    Playground.pendingInterpreterState = undefined;
    Playground.thrownException = undefined;
    rerenderPlayground();
    setTimeout(runInterpreter, 0);
}
/**** suspendBlocklyProgram ****/
function suspendBlocklyProgram() {
    if (Playground.InterpreterState !== 'running') {
        return;
    }
    Playground.pendingInterpreterState = 'suspended';
    rerenderPlayground();
}
/**** resumeBlocklyProgram ****/
function resumeBlocklyProgram() {
    if (Playground.InterpreterState !== 'suspended') {
        return;
    }
    Playground.InterpreterState = 'running';
    Playground.pendingInterpreterState = undefined;
    Playground.thrownException = undefined;
    rerenderPlayground();
    setTimeout(runInterpreter, 0);
}
/**** abortBlocklyProgram ****/
function abortBlocklyProgram() {
    switch (Playground.InterpreterState) {
        case 'idle': return;
        case 'running':
            Playground.pendingInterpreterState = 'idle';
            break;
        case 'suspended': Playground.InterpreterState = 'idle';
    }
    rerenderPlayground();
}
/**** runInterpreter ****/
function runInterpreter() {
    if (Playground.pendingInterpreterState != null) { // 'suspended' || 'idle'
        Playground.InterpreterState = Playground.pendingInterpreterState;
        Playground.pendingInterpreterState = undefined;
        rerenderPlayground();
        return;
    }
    try {
        for (;;) {
            Playground.Interpreter.step();
            if (Playground.thrownException != null) {
                throw Playground.thrownException;
            }
            if (Playground.InterpreterState === 'idle') {
                return;
            }
            if (Playground.pendingInterpreterState != null) { // 'suspended' || 'idle'
                Playground.InterpreterState = Playground.pendingInterpreterState;
                Playground.pendingInterpreterState = undefined;
                rerenderPlayground();
                return;
            }
            switch (Playground.Interpreter.getStatus()) {
                case Interpreter.Status.DONE:
                    Playground.InterpreterState = 'idle';
                    Playground.pendingInterpreterState = undefined;
                    rerenderPlayground();
                    return;
                case Interpreter.Status.STEP:
                    break;
                case Interpreter.Status.TASK:
                case Interpreter.Status.ASYNC:
                    setTimeout(runInterpreter, 0);
                    return;
            }
        }
    }
    catch (Signal) {
        console.log('Blockly Execution Error', Signal);
        alert('Blockly Execution Error\n\n' + Signal);
        Playground.InterpreterState = 'idle';
        Playground.pendingInterpreterState = undefined;
        rerenderPlayground();
    }
}
//------------------------------------------------------------------------------
//--                                Workspace                                 --
//------------------------------------------------------------------------------
/**** LineFeed ****/
Blockly.Blocks['LineFeed'] = {
    init: function () {
        this.jsonInit({
            type: 'LineFeed',
            tooltip: 'represents a line-feed character',
            helpUrl: '',
            message0: 'LineFeed',
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['LineFeed'] = function (Block, Generator) {
    return [`"\\n"`, Order.FUNCTION_CALL];
};
/**** MultilineText ****/
Blockly.Blocks['MultilineText'] = {
    init: function () {
        this.jsonInit({
            type: 'MultilineText',
            tooltip: 'allows to enter multi-line text',
            helpUrl: '',
            message0: 'text %1',
            args0: [{ type: 'field_multilineinput', name: 'text', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['MultilineText'] = function (Block, Generator) {
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`${Text}`, Order.FUNCTION_CALL];
};
/**** KeyValuePair ****/
Blockly.Blocks['KeyValuePair'] = {
    init: function () {
        this.jsonInit({
            type: 'KeyValuePair',
            tooltip: 'creates a list containing a key and a value',
            helpUrl: '',
            message0: 'key %1 value %2',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'value' }
            ],
            output: 'Array',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['KeyValuePair'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`[${Key},${Value}]`, Order.FUNCTION_CALL];
};
/**** createObject ****/
Blockly.Blocks['createObject'] = {
    init: function () {
        this.jsonInit({
            type: 'createObject',
            tooltip: 'creates a new object',
            helpUrl: '',
            message0: 'new object',
            args0: [],
            output: 'Object',
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['createObject'] = function (Block, Generator) {
    return ['{}', Order.FUNCTION_CALL];
};
/**** ObjectHasProperty ****/
Blockly.Blocks['ObjectHasProperty'] = {
    init: function () {
        this.jsonInit({
            type: 'ObjectHasProperty',
            tooltip: 'returns true if the given object contains the given property',
            helpUrl: '',
            message0: 'object %1 has %2',
            args0: [
                { type: 'input_value', name: 'object', check: 'Object' },
                { type: 'input_value', name: 'key', check: ['Number', 'String'] }
            ],
            output: 'Boolean',
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ObjectHasProperty'] = function (Block, Generator) {
    let Object = Generator.valueToCode(Block, 'object', Order.NONE) || '{}';
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`(${Key} in ${Object})`, Order.FUNCTION_CALL];
};
/**** getObjectProperty ****/
Blockly.Blocks['getObjectProperty'] = {
    init: function () {
        this.jsonInit({
            type: 'getObjectProperty',
            tooltip: 'returns the current value of a property in an object',
            helpUrl: '',
            message0: 'from object %1 get %2',
            args0: [
                { type: 'input_value', name: 'object', check: 'Object' },
                { type: 'input_value', name: 'key', check: ['Number', 'String'] }
            ],
            output: 'any',
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['getObjectProperty'] = function (Block, Generator) {
    let Object = Generator.valueToCode(Block, 'object', Order.NONE) || '{}';
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`(${Object}[${Key}])`, Order.FUNCTION_CALL];
};
/**** setObjectProperty ****/
Blockly.Blocks['setObjectProperty'] = {
    init: function () {
        this.jsonInit({
            type: 'setObjectProperty',
            tooltip: 'sets a property in an object to a new value',
            helpUrl: '',
            message0: 'in object %1 set %2 to %3',
            args0: [
                { type: 'input_value', name: 'object', check: 'Object' },
                { type: 'input_value', name: 'key', check: ['Number', 'String'] },
                { type: 'input_value', name: 'value' }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['setObjectProperty'] = function (Block, Generator) {
    let Object = Generator.valueToCode(Block, 'object', Order.NONE) || '{}';
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return `${Object}[${Key}] = ${Value};\n`;
};
/**** deleteObjectProperty ****/
Blockly.Blocks['deleteObjectProperty'] = {
    init: function () {
        this.jsonInit({
            type: 'deleteObjectProperty',
            tooltip: 'deletes a property from an object',
            helpUrl: '',
            message0: 'from object %1 delete %2',
            args0: [
                { type: 'input_value', name: 'object', check: 'Object' },
                { type: 'input_value', name: 'key', check: ['Number', 'String'] }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['deleteObjectProperty'] = function (Block, Generator) {
    let Object = Generator.valueToCode(Block, 'object', Order.NONE) || '{}';
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `delete ${Object}[${Key}];\n`;
};
/**** PropertiesOfObject ****/
Blockly.Blocks['PropertiesOfObject'] = {
    init: function () {
        this.jsonInit({
            type: 'PropertiesOfObject',
            tooltip: 'returns s list with the names of all properties in an object',
            helpUrl: '',
            message0: 'properties of object %1',
            args0: [{ type: 'input_value', name: 'object', check: 'Object' }],
            output: 'Array',
            colour: 260,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['PropertiesOfObject'] = function (Block, Generator) {
    let Object = Generator.valueToCode(Block, 'object', Order.NONE) || '{}';
    return [`PropertiesOfObject(${Object})`, Order.FUNCTION_CALL];
};
/**** ContextKeys ****/
Blockly.Blocks['ContextKeys'] = {
    init: function () {
        this.jsonInit({
            type: 'ContextKeys',
            tooltip: 'produces a list with the keys of all items in the Playground context',
            helpUrl: '',
            message0: 'list of context keys',
            args0: [],
            output: 'Array',
            colour: 330
        });
    }
};
javascriptGenerator.forBlock['ContextKeys'] = function (Block, Generator) {
    return [`ContextKeys()`, Order.FUNCTION_CALL];
};
/**** clearContext ****/
Blockly.Blocks['clearContext'] = {
    init: function () {
        this.jsonInit({
            type: 'clearContext',
            tooltip: 'clears the Playground context',
            helpUrl: '',
            message0: 'clear context',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 330
        });
    }
};
javascriptGenerator.forBlock['clearContext'] = function (Block, Generator) {
    return `clearContext();\n`;
};
/**** getFromContext ****/
Blockly.Blocks['getFromContext'] = {
    init: function () {
        this.jsonInit({
            type: 'getFromContext',
            tooltip: 'retrieves an item from the Playground context',
            helpUrl: '',
            message0: 'value of context item %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            output: 'String',
            colour: 330,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['getFromContext'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`getFromContext(${Key})`, Order.FUNCTION_CALL];
};
/**** setInContext ****/
Blockly.Blocks['setInContext'] = {
    init: function () {
        this.jsonInit({
            type: 'setInContext',
            tooltip: 'sets an item in the Playground context',
            helpUrl: '',
            message0: 'set context item %1 to %2',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'value' }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 330,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['setInContext'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return `setInContext(${Key},${Value});\n`;
};
/**** removeFromContext ****/
Blockly.Blocks['removeFromContext'] = {
    init: function () {
        this.jsonInit({
            type: 'removeFromContext',
            tooltip: 'removes an item of the Playground context',
            helpUrl: '',
            message0: 'remove context item %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 330,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['removeFromContext'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `removeFromContext(${Key});\n`;
};
/**** preserveContextItem ****/
Blockly.Blocks['preserveContextItem'] = {
    init: function () {
        this.jsonInit({
            type: 'preserveContextItem',
            tooltip: 'preserves an item of the Playground context in the Browser Storage',
            helpUrl: '',
            message0: 'preserve context item %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 330,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['preserveContextItem'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `preserveContextItem(${Key});\n`;
};
/**** restoreContextItem ****/
Blockly.Blocks['restoreContextItem'] = {
    init: function () {
        this.jsonInit({
            type: 'restoreContextItem',
            tooltip: 'restores an item of the Playground context from the Browser Storage',
            helpUrl: '',
            message0: 'restore context item %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 330,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['restoreContextItem'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `restoreContextItem(${Key});\n`;
};
/**** showWorkspace ****/
Blockly.Blocks['showWorkspace'] = {
    init: function () {
        this.jsonInit({
            type: 'showWorkspace',
            tooltip: 'switches to the Playground Workspace',
            helpUrl: '',
            message0: 'show workspace',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['showWorkspace'] = function (Block, Generator) {
    return `showWorkspace();\n`;
};
/**** showUI ****/
Blockly.Blocks['showUI'] = {
    init: function () {
        this.jsonInit({
            type: 'showUI',
            tooltip: 'switches to the Playground User Interface',
            helpUrl: '',
            message0: 'show UI',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['showUI'] = function (Block, Generator) {
    return `showUI();\n`;
};
/**** UIElements ****/
Blockly.Blocks['UIElements'] = {
    init: function () {
        this.jsonInit({
            type: 'UIElements',
            tooltip: 'produces a list with the keys of all Playground User Interface elements',
            helpUrl: '',
            message0: 'list of UI element keys',
            args0: [],
            output: 'Array',
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['UIElements'] = function (Block, Generator) {
    return [`UIElements()`, Order.FUNCTION_CALL];
};
/**** UIhasElement ****/
Blockly.Blocks['UIhasElement'] = {
    init: function () {
        this.jsonInit({
            type: 'UIhasElement',
            tooltip: 'returns true if the Playground User Interface contains an element with the given key',
            helpUrl: '',
            message0: 'UI has element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['UIhasElement'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`UIhasElement(${Key})`, Order.FUNCTION_CALL];
};
/**** clearUI ****/
Blockly.Blocks['clearUI'] = {
    init: function () {
        this.jsonInit({
            type: 'clearUI',
            tooltip: 'clears the Playground User Interface',
            helpUrl: '',
            message0: 'clear UI',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['clearUI'] = function (Block, Generator) {
    return `clearUI();\n`;
};
/**** enableUI ****/
Blockly.Blocks['enableUI'] = {
    init: function () {
        this.jsonInit({
            type: 'enableUI',
            tooltip: 'enables the Playground User Interface as a whole',
            helpUrl: '',
            message0: 'enable UI as a whole',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['enableUI'] = function (Block, Generator) {
    return `enableUI();\n`;
};
/**** disableUI ****/
Blockly.Blocks['disableUI'] = {
    init: function () {
        this.jsonInit({
            type: 'disableUI',
            tooltip: 'disables the Playground User Interface as a whole',
            helpUrl: '',
            message0: 'disable UI as a whole',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['disableUI'] = function (Block, Generator) {
    return `disableUI();\n`;
};
/**** appendToUI ****/
Blockly.Blocks['appendToUI'] = {
    init: function () {
        this.jsonInit({
            type: 'appendToUI',
            tooltip: 'appends an element to the Playground User Interface',
            helpUrl: '',
            message0: 'append UI element %1 type %2 label %3 options %4',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'type', options: [
                        ['text line input', 'textline-input'],
                        ['password input', 'password-input'],
                        ['number input', 'number-input'],
                        ['URL input', 'url-input'],
                        ['text input', 'text-input'],
                        ['text line output', 'textline-output'],
                        ['number output', 'number-output'],
                        ['text output', 'text-output'],
                        ['text view', 'text'],
                        ['hint view', 'hint'],
                    ] },
                { type: 'input_value', name: 'label', check: 'String' },
                { type: 'input_value', name: 'options', check: 'Array' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['appendToUI'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Type = Generator.valueToCode(Block, 'type', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    let OptionList = Generator.valueToCode(Block, 'options', Order.NONE) || '[]';
    return `appendToUI(${Key},${Label},${Type},${OptionList});\n`;
};
/**** appendTextlineInput ****/
Blockly.Blocks['appendTextlineInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendTextlineInput',
            tooltip: 'appends a text line input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append text line input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendTextlineInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendTextlineInput(${Key},${Label});\n`;
};
/**** appendPasswordInput ****/
Blockly.Blocks['appendPasswordInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendPasswordInput',
            tooltip: 'appends a password input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append password input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendPasswordInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendPasswordInput(${Key},${Label});\n`;
};
/**** appendNumberInput ****/
Blockly.Blocks['appendNumberInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendNumberInput',
            tooltip: 'appends a number input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append number input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendNumberInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendNumberInput(${Key},${Label});\n`;
};
/**** appendURLInput ****/
Blockly.Blocks['appendURLInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendURLInput',
            tooltip: 'appends a URL input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append URL input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendURLInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendURLInput(${Key},${Label});\n`;
};
/**** appendTextInput ****/
Blockly.Blocks['appendTextInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendTextInput',
            tooltip: 'appends a text input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append text input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendTextInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendTextInput(${Key},${Label});\n`;
};
/**** appendSpeechInput ****/
Blockly.Blocks['appendSpeechInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendSpeechInput',
            tooltip: 'appends a speech input element to the Playground User Interface',
            helpUrl: '',
            message0: 'append speech input element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendSpeechInput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendSpeechInput(${Key},${Label});\n`;
};
/**** appendCheckbox ****/
Blockly.Blocks['appendCheckbox'] = {
    init: function () {
        this.jsonInit({
            type: 'appendCheckbox',
            tooltip: 'appends a checkbox element to the Playground User Interface',
            helpUrl: '',
            message0: 'append checkbox element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendCheckbox'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendCheckbox(${Key},${Label});\n`;
};
/**** appendRadiobuttonGroup ****/
Blockly.Blocks['appendRadiobuttonGroup'] = {
    init: function () {
        this.jsonInit({
            type: 'appendRadiobuttonGroup',
            tooltip: 'appends a radiobutton group element to the Playground User Interface',
            helpUrl: '',
            message0: 'append radiobutton group element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendRadiobuttonGroup'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendRadiobuttonGroup(${Key},${Label});\n`;
};
/**** appendDropDown ****/
Blockly.Blocks['appendDropDown'] = {
    init: function () {
        this.jsonInit({
            type: 'appendDropDown',
            tooltip: 'appends a drop-down element to the Playground User Interface',
            helpUrl: '',
            message0: 'append drop-down element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendDropDown'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendDropDown(${Key},${Label});\n`;
};
/**** appendButton ****/
Blockly.Blocks['appendButton'] = {
    init: function () {
        this.jsonInit({
            type: 'appendButton',
            tooltip: 'appends a button element to the Playground User Interface',
            helpUrl: '',
            message0: 'append button element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendButton'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendButton(${Key},${Label});\n`;
};
/**** appendTextlineOutput ****/
Blockly.Blocks['appendTextlineOutput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendTextlineOutput',
            tooltip: 'appends a text line output element to the Playground User Interface',
            helpUrl: '',
            message0: 'append text line output element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendTextlineOutput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendTextlineOutput(${Key},${Label});\n`;
};
/**** appendNumberOutput ****/
Blockly.Blocks['appendNumberOutput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendNumberOutput',
            tooltip: 'appends a number output element to the Playground User Interface',
            helpUrl: '',
            message0: 'append number output element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendNumberOutput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendNumberOutput(${Key},${Label});\n`;
};
/**** appendTextOutput ****/
Blockly.Blocks['appendTextOutput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendTextOutput',
            tooltip: 'appends a text output element to the Playground User Interface',
            helpUrl: '',
            message0: 'append text output element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendTextOutput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendTextOutput(${Key},${Label});\n`;
};
/**** appendFinePrintOutput ****/
Blockly.Blocks['appendFinePrintOutput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendFinePrintOutput',
            tooltip: 'appends a "fineprint" output element to the Playground User Interface',
            helpUrl: '',
            message0: 'append fineprint output element %1 labelled %2 to UI',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'label', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendFinePrintOutput'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendFinePrintOutput(${Key},${Label});\n`;
};
/**** appendText ****/
Blockly.Blocks['appendText'] = {
    init: function () {
        this.jsonInit({
            type: 'appendText',
            tooltip: 'appends an unlabelled text view element to the Playground User Interface',
            helpUrl: '',
            message0: 'append unlabelled text view element %1 to UI',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendText'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `appendText(${Key});\n`;
};
/**** appendFinePrint ****/
Blockly.Blocks['appendFinePrint'] = {
    init: function () {
        this.jsonInit({
            type: 'appendFinePrint',
            tooltip: 'appends an unlabelled "fine print" view element to the Playground User Interface',
            helpUrl: '',
            message0: 'append unlabelled "fine print" view element %1 to UI',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendFinePrint'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `appendFinePrint(${Key});\n`;
};
/**** appendAPIServerInput ****/
Blockly.Blocks['appendAPIServerInput'] = {
    init: function () {
        this.jsonInit({
            type: 'appendAPIServerInput',
            tooltip: 'appends a URL input element for API Servers to the Playground User Interface',
            helpUrl: '',
            message0: 'append API Server input element labelled %1 to UI',
            args0: [{ type: 'input_value', name: 'label', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendAPIServerInput'] = function (Block, Generator) {
    let Label = Generator.valueToCode(Block, 'label', Order.NONE) || '""';
    return `appendAPIServerInput(${Label});\n`;
};
/**** configureUI ****/
Blockly.Blocks['configureUI'] = {
    init: function () {
        this.jsonInit({
            type: 'configureUI',
            tooltip: 'sets an option for an element in the Playground User Interface',
            helpUrl: '',
            message0: 'configure UI element %1 option %2 value %3',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'option', check: 'String' },
                { type: 'input_value', name: 'value', check: ['Boolean', 'Number', 'String'] },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['configureUI'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Option = Generator.valueToCode(Block, 'option', Order.NONE) || '""';
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || '[]';
    return `configureUI(${Key},${Option},${Value});\n`;
};
/**** ConfigurationOf ****/
Blockly.Blocks['ConfigurationOf'] = {
    init: function () {
        this.jsonInit({
            type: 'ConfigurationOf',
            tooltip: 'returns a current option setting of an element in the Playground User Interface',
            helpUrl: '',
            message0: 'Option %1 of UI element %2',
            args0: [
                { type: 'input_value', name: 'option', check: 'String' },
                { type: 'input_value', name: 'key', check: 'String' }
            ],
            output: ['Boolean', 'Number', 'String'],
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ConfigurationOf'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Option = Generator.valueToCode(Block, 'option', Order.NONE) || '""';
    return [`ConfigurationOf(${Key},${Option})`, Order.FUNCTION_CALL];
};
/**** EnablingOf ****/
Blockly.Blocks['EnablingOf'] = {
    init: function () {
        this.jsonInit({
            type: 'EnablingOf',
            tooltip: 'returns a current enabling of an element in the Playground User Interface',
            helpUrl: '',
            message0: 'Enabling of UI element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['EnablingOf'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`EnablingOf(${Key})`, Order.FUNCTION_CALL];
};
/**** setEnablingOf ****/
Blockly.Blocks['setEnablingOf'] = {
    init: function () {
        this.jsonInit({
            type: 'setEnablingOf',
            tooltip: 'sets an option for an element in the Playground User Interface',
            helpUrl: '',
            message0: 'set Enabling of UI element %1 to %2',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'value', check: 'Boolean' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['setEnablingOf'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || '[]';
    return `setEnablingOf(${Key},${Value});\n`;
};
/**** enable ****/
Blockly.Blocks['enable'] = {
    init: function () {
        this.jsonInit({
            type: 'enable',
            tooltip: 'enables an element in the Playground User Interface',
            helpUrl: '',
            message0: 'enable UI element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['enable'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `enable(${Key});\n`;
};
/**** disable ****/
Blockly.Blocks['disable'] = {
    init: function () {
        this.jsonInit({
            type: 'disable',
            tooltip: 'disables an element in the Playground User Interface',
            helpUrl: '',
            message0: 'disable UI element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['disable'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `disable(${Key});\n`;
};
/**** isEnabled ****/
Blockly.Blocks['isEnabled'] = {
    init: function () {
        this.jsonInit({
            type: 'isEnabled',
            tooltip: 'checks if an element in the Playground User Interface is enabled',
            helpUrl: '',
            message0: 'UI element %1 is enabled',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['isEnabled'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`isEnabled(${Key})`, Order.FUNCTION_CALL];
};
/**** clearChoicesOf ****/
Blockly.Blocks['clearChoicesOf'] = {
    init: function () {
        this.jsonInit({
            type: 'clearChoicesOf',
            tooltip: 'clears the choices of an element in the Playground User Interface',
            helpUrl: '',
            message0: 'clear choices of UI element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['clearChoicesOf'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `clearChoicesOf(${Key});\n`;
};
/**** appendChoiceTo ****/
Blockly.Blocks['appendChoiceTo'] = {
    init: function () {
        this.jsonInit({
            type: 'appendChoiceTo',
            tooltip: 'appends a choice for an element in the Playground User Interface',
            helpUrl: '',
            message0: 'append Choice %2 to UI element %1',
            args0: [
                { type: 'input_value', name: 'key', check: 'String' },
                { type: 'input_value', name: 'choice', check: 'String' },
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['appendChoiceTo'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    let Choice = Generator.valueToCode(Block, 'choice', Order.NONE) || '[]';
    return `appendChoiceTo(${Key},${Choice});\n`;
};
/**** removeFromUI ****/
Blockly.Blocks['removeFromUI'] = {
    init: function () {
        this.jsonInit({
            type: 'removeFromUI',
            tooltip: 'removes an element from the Playground User Interface',
            helpUrl: '',
            message0: 'remove UI element %1',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['removeFromUI'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return `removeFromUI(${Key});\n`;
};
/**** clearConsole ****/
Blockly.Blocks['clearConsole'] = {
    init: function () {
        this.jsonInit({
            type: 'clearConsole',
            tooltip: 'clears the Console',
            helpUrl: '',
            message0: 'clear Console',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['clearConsole'] = function (Block, Generator) {
    return `clearConsole();\n`;
};
/**** print ****/
Blockly.Blocks['print'] = {
    init: function () {
        this.jsonInit({
            type: 'print',
            tooltip: 'appends the given value to the Console',
            helpUrl: '',
            message0: 'print %1',
            args0: [{ type: 'input_value', name: 'message' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['print'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return `print(${Message});\n`;
};
/**** println ****/
Blockly.Blocks['println'] = {
    init: function () {
        this.jsonInit({
            type: 'println',
            tooltip: 'appends the given value to the Console and starts a new line',
            helpUrl: '',
            message0: 'println %1',
            args0: [{ type: 'input_value', name: 'message' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['println'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return `println(${Message});\n`;
};
/**** clearPendingUIEvents ****/
Blockly.Blocks['clearPendingUIEvents'] = {
    init: function () {
        this.jsonInit({
            type: 'clearPendingUIEvents',
            tooltip: 'clears all pending Playground User Interface events',
            helpUrl: '',
            message0: 'clear pending UI events',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['clearPendingUIEvents'] = function (Block, Generator) {
    return `clearPendingUIEvents();\n`;
};
/**** wheneverUIEventOccuredWithin ****/
Blockly.Blocks['wheneverUIEventOccuredWithin'] = {
    init: function () {
        this.jsonInit({
            type: 'wheneverUIEventOccuredWithin',
            tooltip: 'waits for an event from the Playground User Interface within a given timeout and evaluates the given statements',
            helpUrl: '',
            message0: 'for every UI event\ndo %1 wait up to %2',
            args0: [
                { type: 'input_statement', name: 'body' },
                { type: 'input_value', name: 'timeout', check: 'Number' }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['wheneverUIEventOccuredWithin'] = function (Block, Generator) {
    let Body = Generator.statementToCode(Block, 'body');
    let Timeout = Generator.valueToCode(Block, 'timeout', Order.NONE) || 'undefined';
    return `
(function () {
  try {
    for (;;) {
      var EventReceived = waitForNextUIEvent(${Timeout})
      if (! EventReceived) { break }

      try {
        ${Body}
      } catch (Signal) {
        if (Signal === 'leaveUIEventLoop') { break } else { throw Signal }
      }
    }
    UIEventHandlerWasLeft()
  } catch (Signal) {
    UIEventHandlerWasLeft()
    throw Signal
  }
})();
    `;
};
/**** wheneverUIEventOccured ****/
Blockly.Blocks['wheneverUIEventOccured'] = {
    init: function () {
        this.jsonInit({
            type: 'wheneverUIEventOccured',
            tooltip: 'waits for an event from the Playground User Interface and evaluates the given statements',
            helpUrl: '',
            message0: 'for every UI event\ndo %1',
            args0: [{ type: 'input_statement', name: 'body' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['wheneverUIEventOccured'] = function (Block, Generator) {
    let Body = Generator.statementToCode(Block, 'body');
    return `
;(function () {
  try {
    for (;;) {
      var EventReceived = waitForNextUIEvent(-1)
      if (! EventReceived) { break }

      try {
        ${Body}
      } catch (Signal) {
        if (Signal === 'leaveUIEventLoop') { break } else { throw Signal }
      }
    }
    UIEventHandlerWasLeft()
  } catch (Signal) {
    UIEventHandlerWasLeft()
    throw Signal
  }
})();
    `;
};
/**** ButtonWasClicked ****/
Blockly.Blocks['ButtonWasClicked'] = {
    init: function () {
        this.jsonInit({
            type: 'ButtonWasClicked',
            tooltip: 'checks if a button in the Playground User Interface was clicked',
            helpUrl: '',
            message0: 'UI button %1 was clicked',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ButtonWasClicked'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`ButtonWasClicked(${Key})`, Order.FUNCTION_CALL];
};
/**** InputWasChanged ****/
Blockly.Blocks['InputWasChanged'] = {
    init: function () {
        this.jsonInit({
            type: 'InputWasChanged',
            tooltip: 'checks if an element in the Playground User Interface got new input',
            helpUrl: '',
            message0: 'UI element %1 got new input',
            args0: [{ type: 'input_value', name: 'key', check: 'String' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['InputWasChanged'] = function (Block, Generator) {
    let Key = Generator.valueToCode(Block, 'key', Order.NONE) || '""';
    return [`InputWasChanged(${Key})`, Order.FUNCTION_CALL];
};
/**** leaveUIEventLoop ****/
Blockly.Blocks['leaveUIEventLoop'] = {
    init: function () {
        this.jsonInit({
            type: 'leaveUIEventLoop',
            tooltip: 'leaves the current Playground User Interface event loop',
            helpUrl: '',
            message0: 'leave UI event loop',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['leaveUIEventLoop'] = function (Block, Generator) {
    return `throw 'leaveUIEventLoop';\n`;
};
/**** ChatCompletionFor ****/
Blockly.Blocks['ChatCompletionFor'] = {
    init: function () {
        this.jsonInit({
            type: 'ChatCompletionFor',
            tooltip: 'creates a chat completion for the given list of messages',
            helpUrl: '',
            message0: 'chat completion for %1',
            args0: [{ type: 'input_value', name: 'messages', check: 'Array' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ChatCompletionFor'] = function (Block, Generator) {
    let MessageList = Generator.valueToCode(Block, 'messages', Order.NONE) || '[]';
    return [`ChatCompletionFor(${MessageList},'default_')`, Order.FUNCTION_CALL];
};
/**** ChatCompletionForWithOptionPrefix ****/
Blockly.Blocks['ChatCompletionForWithOptionPrefix'] = {
    init: function () {
        this.jsonInit({
            type: 'ChatCompletionForWithOptionPrefix',
            tooltip: 'creates a chat completion for the given list of messages',
            helpUrl: '',
            message0: 'chat completion for %1 with option prefix %2',
            args0: [
                { type: 'input_value', name: 'messages', check: 'Array' },
                { type: 'input_value', name: 'prefix', check: 'String' },
            ],
            output: 'String',
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['ChatCompletionForWithOptionPrefix'] = function (Block, Generator) {
    let MessageList = Generator.valueToCode(Block, 'messages', Order.NONE) || '[]';
    let OptionPrefix = Generator.valueToCode(Block, 'prefix', Order.NONE) || '""';
    return [`ChatCompletionFor(${MessageList}),${OptionPrefix}`, Order.FUNCTION_CALL];
};
/**** TextCompletionFor ****/
Blockly.Blocks['TextCompletionFor'] = {
    init: function () {
        this.jsonInit({
            type: 'TextCompletionFor',
            tooltip: 'creates a completion for the given prompt',
            helpUrl: '',
            message0: 'text completion for %1',
            args0: [{ type: 'input_value', name: 'prompt', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['TextCompletionFor'] = function (Block, Generator) {
    let Prompt = Generator.valueToCode(Block, 'prompt', Order.NONE) || '""';
    return [`TextCompletionFor(${Prompt},'default_')`, Order.FUNCTION_CALL];
};
/**** TextCompletionForWithOptionPrefix ****/
Blockly.Blocks['TextCompletionForWithOptionPrefix'] = {
    init: function () {
        this.jsonInit({
            type: 'TextCompletionForWithOptionPrefix',
            tooltip: 'creates a completion for the given prompt',
            helpUrl: '',
            message0: 'text completion for %1 with option prefix %2',
            args0: [
                { type: 'input_value', name: 'prompt', check: 'String' },
                { type: 'input_value', name: 'prefix', check: 'String' },
            ],
            output: 'String',
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['TextCompletionForWithOptionPrefix'] = function (Block, Generator) {
    let Prompt = Generator.valueToCode(Block, 'prompt', Order.NONE) || '""';
    let Prefix = Generator.valueToCode(Block, 'prefix', Order.NONE) || '""';
    return [`TextCompletionFor(${Prompt},${Prefix})`, Order.FUNCTION_CALL];
};
/**** SummaryOfText ****/
Blockly.Blocks['SummaryOfText'] = {
    init: function () {
        this.jsonInit({
            type: 'SummaryOfText',
            tooltip: 'creates a summary of the given text',
            helpUrl: '',
            message0: 'summary of %1',
            args0: [{ type: 'input_value', name: 'text', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['SummaryOfText'] = function (Block, Generator) {
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`SummaryOfText(${Text})`, Order.FUNCTION_CALL];
};
/**** ResearchFor ****/
Blockly.Blocks['ResearchFor'] = {
    init: function () {
        this.jsonInit({
            type: 'ResearchFor',
            tooltip: 'conducts a web research with regards to a given objective',
            helpUrl: '',
            message0: 'findings from the web for %1',
            args0: [{ type: 'input_value', name: 'objective', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ResearchFor'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    return [`ResearchFor(${Objective})`, Order.FUNCTION_CALL];
};
/**** SearchPhraseForText ****/
Blockly.Blocks['SearchPhraseForText'] = {
    init: function () {
        this.jsonInit({
            type: 'SearchPhraseForText',
            tooltip: 'creates a search phrase for the given problem',
            helpUrl: '',
            message0: 'search phrase for %1',
            args0: [{ type: 'input_value', name: 'problem', check: 'String' }],
            output: 'Array',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['SearchPhraseForText'] = function (Block, Generator) {
    let Problem = Generator.valueToCode(Block, 'problem', Order.NONE) || '""';
    return [`SearchPhraseForText(${Problem})`, Order.FUNCTION_CALL];
};
/**** FindingsFromText ****/
Blockly.Blocks['FindingsFromText'] = {
    init: function () {
        this.jsonInit({
            type: 'FindingsFromText',
            tooltip: 'extracts information from a given text that leads to the given objective',
            helpUrl: '',
            message0: 'information from %1 useful for %2',
            args0: [
                { type: 'input_value', name: 'text', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['FindingsFromText'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`FindingsFromText(${Text},${Objective})`, Order.FUNCTION_CALL];
};
/**** TextHelpsWith ****/
Blockly.Blocks['TextHelpsWith'] = {
    init: function () {
        this.jsonInit({
            type: 'TextHelpsWith',
            tooltip: 'checks if the given text helps with the given objective',
            helpUrl: '',
            message0: 'is %1 useful for %2',
            args0: [
                { type: 'input_value', name: 'text', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['TextHelpsWith'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`TextHelpsWith(${Text},${Objective})`, Order.FUNCTION_CALL];
};
/**** SolutionMergedFromTexts ****/
Blockly.Blocks['SolutionMergedFromTexts'] = {
    init: function () {
        this.jsonInit({
            type: 'SolutionMergedFromTexts',
            tooltip: 'merges information from two texts to approach the given objective',
            helpUrl: '',
            message0: 'combination of %1 and %2 to approach %3',
            args0: [
                { type: 'input_value', name: 'text1', check: 'String' },
                { type: 'input_value', name: 'text2', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['SolutionMergedFromTexts'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Text1 = Generator.valueToCode(Block, 'text1', Order.NONE) || '""';
    let Text2 = Generator.valueToCode(Block, 'text2', Order.NONE) || '""';
    return [`SolutionMergedFromTexts(${Text1},${Text2},${Objective})`, Order.FUNCTION_CALL];
};
/**** SolutionEncodedFrom ****/
Blockly.Blocks['SolutionEncodedFrom'] = {
    init: function () {
        this.jsonInit({
            type: 'SolutionEncodedFrom',
            tooltip: 'generates a machine-readable result from a given text and a given objective',
            helpUrl: '',
            message0: 'result encoded from %1 for %2',
            args0: [
                { type: 'input_value', name: 'text', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['SolutionEncodedFrom'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`SolutionEncodedFrom(${Text},${Objective})`, Order.FUNCTION_CALL];
};
/**** ComputationOf ****/
Blockly.Blocks['ComputationOf'] = {
    init: function () {
        this.jsonInit({
            type: 'ComputationOf',
            tooltip: 'runs a computation to perform a given task considering any already gathered knowledge',
            helpUrl: '',
            message0: 'computation result for %1',
            args0: [{ type: 'input_value', name: 'objective', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ComputationOf'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    return [`ComputationOf(${Objective})`, Order.FUNCTION_CALL];
};
/**** ParameterListFor ****/
Blockly.Blocks['ParameterListFor'] = {
    init: function () {
        this.jsonInit({
            type: 'ParameterListFor',
            tooltip: 'generates a parameter list for a function to achieve the given objective',
            helpUrl: '',
            message0: 'parameters for function to achieve %1',
            args0: [
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ParameterListFor'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    return [`ParameterListFor(${Objective})`, Order.FUNCTION_CALL];
};
/**** FunctionFor ****/
Blockly.Blocks['FunctionFor'] = {
    init: function () {
        this.jsonInit({
            type: 'FunctionFor',
            tooltip: 'generates a JavaScript function to achieve the given objective with the given parameters',
            helpUrl: '',
            message0: 'function with parameters %1 to achieve %2',
            args0: [
                { type: 'input_value', name: 'parameters', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['FunctionFor'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Parameters = Generator.valueToCode(Block, 'parameters', Order.NONE) || '"[]"';
    return [`FunctionFor(${Objective},${Parameters})`, Order.FUNCTION_CALL];
};
/**** StepsDerivedFromText ****/
Blockly.Blocks['StepsDerivedFromText'] = {
    init: function () {
        this.jsonInit({
            type: 'StepsDerivedFromText',
            tooltip: 'creates a list of steps to perform a given task based on already existing knowledge',
            helpUrl: '',
            message0: 'steps derived from %1',
            args0: [{ type: 'input_value', name: 'objective', check: 'String' }],
            output: 'Array',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['StepsDerivedFromText'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    return [`StepsDerivedFromText(${Objective})`, Order.FUNCTION_CALL];
};
/**** addKnowledgeFrom ****/
Blockly.Blocks['addKnowledgeFrom'] = {
    init: function () {
        this.jsonInit({
            type: 'addKnowledgeFrom',
            tooltip: 'adds a given fact to the already existing knowledge',
            helpUrl: '',
            message0: 'add %1 as a response to %2 to existing knowledge',
            args0: [
                { type: 'input_value', name: 'fact', check: 'String' },
                { type: 'input_value', name: 'objective', check: 'String' }
            ],
            previousStatement: null,
            nextStatement: null,
            colour: 60
        });
    }
};
javascriptGenerator.forBlock['addKnowledgeFrom'] = function (Block, Generator) {
    let Objective = Generator.valueToCode(Block, 'objective', Order.NONE) || '""';
    let Fact = Generator.valueToCode(Block, 'fact', Order.NONE) || '""';
    return `addKnowledgeFrom(${Objective},${Fact});\n`;
};
/**** AnswerGeneratedFor ****/
Blockly.Blocks['AnswerGeneratedFor'] = {
    init: function () {
        this.jsonInit({
            type: 'AnswerGeneratedFor',
            tooltip: 'creates a human-readable response for a given task based on the gathered knowledge',
            helpUrl: '',
            message0: 'answer for %1',
            args0: [{ type: 'input_value', name: 'task', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['AnswerGeneratedFor'] = function (Block, Generator) {
    let Task = Generator.valueToCode(Block, 'task', Order.NONE) || '""';
    return [`AnswerGeneratedFor(${Task})`, Order.FUNCTION_CALL];
};
/**** ValueIsKnowledge ****/
Blockly.Blocks['ValueIsKnowledge'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsKnowledge',
            tooltip: 'returns true if the given value contains knowledge for an AI Agent - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is agent knowledge?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsKnowledge'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsKnowledge(${Value},true)`, Order.FUNCTION_CALL];
};
/**** ValueIsStep ****/
Blockly.Blocks['ValueIsStep'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsStep',
            tooltip: 'returns true if the given value represents a single step for an AI Agent - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is an agent step?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsStep'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsStep(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsStepList ****/
Blockly.Blocks['ValueIsStepList'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsStepList',
            tooltip: 'returns true if the given value contains a list of steps for an AI Agent - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is an agent step list?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsStepList'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsStepList(${Value},true)`, Order.FUNCTION_CALL];
};
/**** ValueIsParameter ****/
Blockly.Blocks['ValueIsParameter'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsParameter',
            tooltip: 'returns true if the given value represents a single JavaScript function parameter specification - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a parameter specification?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsParameter'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsParameter(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsParameterList ****/
Blockly.Blocks['ValueIsParameterList'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsParameterList',
            tooltip: 'returns true if the given value contains a list of JavaScript function parameter specifications - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a parameter specification list?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsParameterList'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsParameterList(${Value},true)`, Order.FUNCTION_CALL];
};
/**** ValueIsWikipediaURL ****/
Blockly.Blocks['ValueIsWikipediaURL'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsWikipediaURL',
            tooltip: 'returns true if the given value is a string containing a Wikipedia URL - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a Wikipedia URL?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsWikipediaURL'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsWikipediaURL(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsWikipediaPageName ****/
Blockly.Blocks['ValueIsWikipediaPageName'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsWikipediaPageName',
            tooltip: 'returns true if the given value is a string containing a Wikipedia page name - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a Wikipedia page name?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsWikipediaPageName'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsWikipediaPageName(${Value})`, Order.FUNCTION_CALL];
};
/**** JSONinText ****/
Blockly.Blocks['JSONinText'] = {
    init: function () {
        this.jsonInit({
            type: 'JSONinText',
            tooltip: 'returns the first JSON object found in a given string (or undefined)',
            helpUrl: '',
            message0: 'JSON object in %1',
            args0: [{ type: 'input_value', name: 'text', check: 'String' }],
            output: ['Boolean', 'Number', 'String', 'Object', 'Array'],
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['JSONinText'] = function (Block, Generator) {
    let Text = Generator.valueToCode(Block, 'text', Order.NONE) || '""';
    return [`JSONinText(${Text})`, Order.FUNCTION_CALL];
};
/**** HTMLtoText ****/
Blockly.Blocks['HTMLtoText'] = {
    init: function () {
        this.jsonInit({
            type: 'HTMLtoText',
            tooltip: 'converts the given HTML into plain formatted text',
            helpUrl: '',
            message0: 'HTML %1 as text',
            args0: [{ type: 'input_value', name: 'html', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['HTMLtoText'] = function (Block, Generator) {
    let HTML = Generator.valueToCode(Block, 'html', Order.NONE) || '""';
    return [`HTMLtoText(${HTML})`, Order.FUNCTION_CALL];
};
/**** TextOfWebDocument ****/
Blockly.Blocks['TextOfWebDocument'] = {
    init: function () {
        this.jsonInit({
            type: 'TextOfWebDocument',
            tooltip: 'loads a text document from the web and returns its contents',
            helpUrl: '',
            message0: 'text of web document %1',
            args0: [{ type: 'input_value', name: 'url', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['TextOfWebDocument'] = function (Block, Generator) {
    let URL = Generator.valueToCode(Block, 'url', Order.NONE) || '""';
    return [`TextOfWebDocument(${URL})`, Order.FUNCTION_CALL];
};
/**** TextOfWikipediaArticle ****/
Blockly.Blocks['TextOfWikipediaArticle'] = {
    init: function () {
        this.jsonInit({
            type: 'TextOfWikipediaArticle',
            tooltip: 'loads a Wikipedia article with a given page name and returns its contents',
            helpUrl: '',
            message0: 'text of Wikipedia article %1',
            args0: [{ type: 'input_value', name: 'pagename', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['TextOfWikipediaArticle'] = function (Block, Generator) {
    let PageName = Generator.valueToCode(Block, 'pagename', Order.NONE) || '""';
    return [`TextOfWikipediaArticle(${PageName})`, Order.FUNCTION_CALL];
};
/**** WebSearch ****/
Blockly.Blocks['WebSearch'] = {
    init: function () {
        this.jsonInit({
            type: 'WebSearch',
            tooltip: 'searches the web and returns a list with URLs of found documents',
            helpUrl: '',
            message0: 'result of web search for %1',
            args0: [{ type: 'input_value', name: 'searchphrase', check: 'String' }],
            output: 'Array',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['WebSearch'] = function (Block, Generator) {
    let SearchPhrase = Generator.valueToCode(Block, 'searchphrase', Order.NONE) || '""';
    return [`WebSearch(${SearchPhrase})`, Order.FUNCTION_CALL];
};
/**** WikipediaSearch ****/
Blockly.Blocks['WikipediaSearch'] = {
    init: function () {
        this.jsonInit({
            type: 'WikipediaSearch',
            tooltip: 'searches Wikipedia and returns a list with the names of found documents',
            helpUrl: '',
            message0: 'result of Wikipedia search for %1',
            args0: [{ type: 'input_value', name: 'searchphrase', check: 'String' }],
            output: 'Array',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['WikipediaSearch'] = function (Block, Generator) {
    let SearchPhrase = Generator.valueToCode(Block, 'searchphrase', Order.NONE) || '""';
    return [`WikipediaSearch(${SearchPhrase})`, Order.FUNCTION_CALL];
};
/**** nop ****/
Blockly.Blocks['nop'] = {
    init: function () {
        this.jsonInit({
            type: 'nop',
            tooltip: 'does nothing',
            helpUrl: '',
            message0: ' ',
            args0: [],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['nop'] = function (Block, Generator) {
    return '\n';
};
/**** throwException ****/
Blockly.Blocks['throwException'] = {
    init: function () {
        this.jsonInit({
            type: 'throwException',
            tooltip: 'throws an exception',
            helpUrl: '',
            message0: 'throw %1',
            args0: [{ type: 'input_value', name: 'message', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['throwException'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return `throw ${Message};\n`;
};
/**** wait ****/
Blockly.Blocks['wait'] = {
    init: function () {
        this.jsonInit({
            type: 'wait',
            tooltip: 'waits for a given number of seconds',
            helpUrl: '',
            message0: 'wait %1 second(s)',
            args0: [{ type: 'input_value', name: 'duration', check: 'Number' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['wait'] = function (Block, Generator) {
    let Duration = Generator.valueToCode(Block, 'duration', Order.NONE) || '0';
    Duration = Math.max(0, Math.round(Duration * 1000));
    return `wait(${Duration});\n`;
};
/**** alert ****/
Blockly.Blocks['alert'] = {
    init: function () {
        this.jsonInit({
            type: 'alert',
            tooltip: 'displays a given message in a pop-up dialog, halting the program until dismissed',
            helpUrl: '',
            message0: 'show %1 in alert dialog',
            args0: [{ type: 'input_value', name: 'message', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['alert'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return `alert(${Message});\n`;
};
/**** confirm ****/
Blockly.Blocks['confirm'] = {
    init: function () {
        this.jsonInit({
            type: 'confirm',
            tooltip: 'displays a given message in a pop-up dialog, halting the program until the user confirmed',
            helpUrl: '',
            message0: 'confirm %1 in pop-up dialog',
            args0: [{ type: 'input_value', name: 'message', check: 'String' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['confirm'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return [`confirm(${Message})`, Order.FUNCTION_CALL];
};
/**** prompt ****/
Blockly.Blocks['prompt'] = {
    init: function () {
        this.jsonInit({
            type: 'prompt',
            tooltip: 'displays a given message in a pop-up dialog, halting the program until the user confirmed',
            helpUrl: '',
            message0: 'ask for %1 in pop-up dialog',
            args0: [{ type: 'input_value', name: 'message', check: 'String' }],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['prompt'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return [`prompt(${Message})`, Order.FUNCTION_CALL];
};
/**** prompt_with_default ****/
Blockly.Blocks['prompt_with_default'] = {
    init: function () {
        this.jsonInit({
            type: 'prompt_with_default',
            tooltip: 'displays a given message in a pop-up dialog, halting the program until the user confirmed',
            helpUrl: '',
            message0: 'ask for %1 with default %2 in pop-up dialog',
            args0: [
                { type: 'input_value', name: 'message', check: 'String' },
                { type: 'input_value', name: 'default', check: 'String' },
            ],
            output: 'String',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['prompt_with_default'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    let Default = Generator.valueToCode(Block, 'default', Order.NONE) || '""';
    return [`prompt(${Message},${Default})`, Order.FUNCTION_CALL];
};
/**** speak ****/
Blockly.Blocks['speak'] = {
    init: function () {
        this.jsonInit({
            type: 'speak',
            tooltip: 'speaks a given message using text-to-speach synthesis',
            helpUrl: '',
            message0: 'speak %1',
            args0: [{ type: 'input_value', name: 'message', check: 'String' }],
            previousStatement: null,
            nextStatement: null,
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['speak'] = function (Block, Generator) {
    let Message = Generator.valueToCode(Block, 'message', Order.NONE) || '""';
    return `speak(${Message});\n`;
};
/**** ValueIsNotEmpty ****/
Blockly.Blocks['ValueIsNotEmpty'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsNotEmpty',
            tooltip: 'returns true if the given value is a non-empty string - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a non-empty string?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsNotEmpty'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsNotEmpty(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsNumber ****/
Blockly.Blocks['ValueIsNumber'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsNumber',
            tooltip: 'returns true if the given value is a number - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a number?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsNumber'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsNumber(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsNumberInRange ****/
Blockly.Blocks['ValueIsNumberInRange'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsNumberInRange',
            tooltip: 'returns true if the given value is a number within the given range - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a number within %2 and %3 incl. minimum %4 and maximum %5?',
            args0: [
                { type: 'input_value', name: 'value' },
                { type: 'input_value', name: 'minimum', check: 'Number' },
                { type: 'input_value', name: 'maximum', check: 'Number' },
                { type: 'input_value', name: 'withMinimum', check: 'Boolean' },
                { type: 'input_value', name: 'withMaximum', check: 'Boolean' }
            ],
            output: 'Boolean',
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['ValueIsNumberInRange'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    let Minimum = Generator.valueToCode(Block, 'minimum', Order.NONE) || 'undefined';
    let Maximum = Generator.valueToCode(Block, 'maximum', Order.NONE) || 'undefined';
    let withMinimum = Generator.valueToCode(Block, 'withMinimum', Order.NONE) || 'undefined';
    let withMaximum = Generator.valueToCode(Block, 'withMaximum', Order.NONE) || 'undefined';
    return [`ValueIsNumberInRange(${Value},${Minimum},${Maximum},${withMinimum},${withMaximum})`, Order.FUNCTION_CALL];
};
/**** ValueIsInteger ****/
Blockly.Blocks['ValueIsInteger'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsInteger',
            tooltip: 'returns true if the given value is an integer - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is an integer?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsInteger'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsInteger(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsIntegerInRange ****/
Blockly.Blocks['ValueIsIntegerInRange'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsIntegerInRange',
            tooltip: 'returns true if the given value is an integer within the given range - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is an integer within %2 and %3?',
            args0: [
                { type: 'input_value', name: 'value' },
                { type: 'input_value', name: 'minimum', check: 'Number' },
                { type: 'input_value', name: 'maximum', check: 'Number' }
            ],
            output: 'Boolean',
            colour: 60,
            inputsInline: false
        });
    }
};
javascriptGenerator.forBlock['ValueIsIntegerInRange'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    let Minimum = Generator.valueToCode(Block, 'minimum', Order.NONE) || 'undefined';
    let Maximum = Generator.valueToCode(Block, 'maximum', Order.NONE) || 'undefined';
    return [`ValueIsIntegerInRange(${Value},${Minimum},${Maximum})`, Order.FUNCTION_CALL];
};
/**** ValueIsOrdinal ****/
Blockly.Blocks['ValueIsOrdinal'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsOrdinal',
            tooltip: 'returns true if the given value is an ordinal number - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is an ordinal number?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsOrdinal'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsOrdinal(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsCardinal ****/
Blockly.Blocks['ValueIsCardinal'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsCardinal',
            tooltip: 'returns true if the given value is a cardinal number - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a cardinal number?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsCardinal'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsCardinal(${Value})`, Order.FUNCTION_CALL];
};
/**** ValueIsStringMatching ****/
Blockly.Blocks['ValueIsStringMatching'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsStringMatching',
            tooltip: 'returns true if the given value is a string matchign a given RegExp pattern - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a string matching %2?',
            args0: [
                { type: 'input_value', name: 'value' },
                { type: 'input_value', name: 'pattern', check: 'String' }
            ],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsStringMatching'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    let Pattern = Generator.valueToCode(Block, 'pattern', Order.NONE) || 'undefined';
    return [`ValueIsStringMatching(${Value},${Pattern})`, Order.FUNCTION_CALL];
};
/**** ValueIsURL ****/
Blockly.Blocks['ValueIsURL'] = {
    init: function () {
        this.jsonInit({
            type: 'ValueIsURL',
            tooltip: 'returns true if the given value is a string containing a URL - or false otherwise',
            helpUrl: '',
            message0: 'value %1 is a URL?',
            args0: [{ type: 'input_value', name: 'value' }],
            output: 'Boolean',
            colour: 60,
            inputsInline: true
        });
    }
};
javascriptGenerator.forBlock['ValueIsURL'] = function (Block, Generator) {
    let Value = Generator.valueToCode(Block, 'value', Order.NONE) || 'undefined';
    return [`ValueIsURL(${Value})`, Order.FUNCTION_CALL];
};
/**** Workspace Specification ****/
const WorkspaceSpecification = {
    grid: { spacing: 20, length: 1, color: '#DDDDDD', snap: true },
    //  media:'...',
    toolbox: {
        kind: 'categoryToolbox',
        contents: [
            {
                kind: "category",
                name: "Logic",
                contents: [
                    { kind: "block", type: "controls_if" },
                    { kind: "block", type: "logic_compare" },
                    { kind: "block", type: "logic_operation" },
                    { kind: "block", type: "logic_negate" },
                    { kind: "block", type: "logic_boolean" },
                    { kind: "block", type: "logic_null" },
                    { kind: "block", type: "logic_ternary" }
                ]
            }, {
                kind: "category",
                name: "Loops",
                contents: [
                    { kind: "block", type: "controls_repeat_ext" },
                    { kind: "block", type: "controls_whileUntil" },
                    { kind: "block", type: "controls_for" },
                    { kind: "block", type: "controls_forEach" },
                    { kind: "block", type: "controls_flow_statements" }
                ]
            }, {
                kind: "category",
                name: "Math",
                contents: [
                    { kind: "block", type: "math_number" },
                    { kind: "block", type: "math_arithmetic" },
                    { kind: "block", type: "math_single" },
                    { kind: "block", type: "math_trig" },
                    { kind: "block", type: "math_constant" },
                    { kind: "block", type: "math_number_property" },
                    { kind: "block", type: "math_round" },
                    { kind: "block", type: "math_on_list" },
                    { kind: "block", type: "math_modulo" },
                    { kind: "block", type: "math_constrain" },
                    { kind: "block", type: "math_random_int" },
                    { kind: "block", type: "math_random_float" }
                ]
            }, {
                kind: "category",
                name: "Text",
                contents: [
                    { kind: "block", type: "text" },
                    { kind: "block", type: "LineFeed" },
                    { kind: "block", type: "text_join" },
                    { kind: "block", type: "text_append" },
                    { kind: "block", type: "text_length" },
                    { kind: "block", type: "text_isEmpty" },
                    { kind: "block", type: "text_indexOf" },
                    { kind: "block", type: "text_charAt" },
                    { kind: "block", type: "text_getSubstring" },
                    { kind: "block", type: "text_changeCase" },
                    { kind: "block", type: "text_trim" },
                    //            {kind:"block", type:"text_print"},
                    //            {kind:"block", type:"text_prompt_ext"}
                ]
            }, {
                kind: "category",
                name: "Lists",
                contents: [
                    { kind: "block", type: "lists_create_with" },
                    { kind: "block", type: "lists_repeat" },
                    { kind: "block", type: "lists_length" },
                    { kind: "block", type: "lists_isEmpty" },
                    { kind: "block", type: "lists_indexOf" },
                    { kind: "block", type: "lists_getIndex" },
                    { kind: "block", type: "lists_setIndex" },
                    { kind: "block", type: "lists_getSublist" },
                    { kind: "block", type: "lists_split" },
                    { kind: "block", type: "lists_sort" },
                    //            {kind:"block", type:"KeyValuePair"}
                ]
            },
            {
                kind: "category",
                name: "Objects",
                contents: [
                    { kind: "block", type: "createObject" },
                    { kind: "block", type: "ObjectHasProperty" },
                    { kind: "block", type: "getObjectProperty" },
                    { kind: "block", type: "setObjectProperty" },
                    { kind: "block", type: "deleteObjectProperty" },
                    { kind: "block", type: "PropertiesOfObject" },
                ]
            }, {
                kind: "category",
                name: "Context",
                contents: [
                    { kind: "block", type: "ContextKeys" },
                    { kind: "block", type: "clearContext" },
                    { kind: "block", type: "getFromContext" },
                    { kind: "block", type: "setInContext" },
                    { kind: "block", type: "removeFromContext" },
                    { kind: "block", type: "preserveContextItem" },
                    { kind: "block", type: "restoreContextItem" },
                ]
            }, {
                kind: "category",
                name: "User Interface",
                contents: [
                    { kind: "block", type: "showWorkspace" },
                    { kind: "block", type: "showUI" },
                    { kind: "block", type: "UIElements" },
                    { kind: "block", type: "UIhasElement" },
                    { kind: "block", type: "clearUI" },
                    { kind: "block", type: "enableUI" },
                    { kind: "block", type: "disableUI" },
                    //            {kind:"block", type:"appendToUI"},
                    { kind: "block", type: "removeFromUI" },
                    { kind: "block", type: "appendTextlineInput" },
                    { kind: "block", type: "appendPasswordInput" },
                    { kind: "block", type: "appendNumberInput" },
                    { kind: "block", type: "appendURLInput" },
                    { kind: "block", type: "appendTextInput" },
                    { kind: "block", type: "appendSpeechInput" },
                    { kind: "block", type: "appendCheckbox" },
                    { kind: "block", type: "appendRadiobuttonGroup" },
                    { kind: "block", type: "appendDropDown" },
                    { kind: "block", type: "appendButton" },
                    { kind: "block", type: "appendTextlineOutput" },
                    { kind: "block", type: "appendNumberOutput" },
                    { kind: "block", type: "appendTextOutput" },
                    { kind: "block", type: "appendFinePrintOutput" },
                    { kind: "block", type: "appendText" },
                    { kind: "block", type: "appendFinePrint" },
                    { kind: "block", type: "appendAPIServerInput" },
                    { kind: "block", type: "configureUI" },
                    { kind: "block", type: "ConfigurationOf" },
                    { kind: "block", type: "EnablingOf" },
                    { kind: "block", type: "setEnablingOf" },
                    { kind: "block", type: "enable" },
                    { kind: "block", type: "disable" },
                    { kind: "block", type: "isEnabled" },
                    { kind: "block", type: "clearChoicesOf" },
                    { kind: "block", type: "appendChoiceTo" },
                    { kind: "block", type: "clearConsole" },
                    { kind: "block", type: "print" },
                    { kind: "block", type: "println" },
                    { kind: "block", type: "clearPendingUIEvents" },
                    { kind: "block", type: "wheneverUIEventOccuredWithin" },
                    { kind: "block", type: "wheneverUIEventOccured" },
                    { kind: "block", type: "ButtonWasClicked" },
                    { kind: "block", type: "InputWasChanged" },
                    { kind: "block", type: "leaveUIEventLoop" },
                ]
            }, {
                kind: "category",
                name: "AI Basics",
                contents: [
                    { kind: "block", type: "ChatCompletionFor" },
                    { kind: "block", type: "ChatCompletionForWithOptionPrefix" },
                    { kind: "block", type: "TextCompletionFor" },
                    { kind: "block", type: "TextCompletionForWithOptionPrefix" },
                ]
            }, {
                kind: "category",
                name: "AI Mezzanines",
                contents: [
                    { kind: "block", type: "SummaryOfText" },
                    { kind: "block", type: "ResearchFor" },
                    { kind: "block", type: "SearchPhraseForText" },
                    { kind: "block", type: "FindingsFromText" },
                    { kind: "block", type: "TextHelpsWith" },
                    { kind: "block", type: "SolutionMergedFromTexts" },
                    { kind: "block", type: "SolutionEncodedFrom" },
                    { kind: "block", type: "ComputationOf" },
                    { kind: "block", type: "ParameterListFor" },
                    { kind: "block", type: "FunctionFor" },
                    { kind: "block", type: "StepsDerivedFromText" },
                    { kind: "block", type: "addKnowledgeFrom" },
                    { kind: "block", type: "AnswerGeneratedFor" },
                ]
            }, {
                kind: "category",
                name: "AI Support",
                contents: [
                    { kind: "block", type: "ValueIsKnowledge" },
                    { kind: "block", type: "ValueIsStep" },
                    { kind: "block", type: "ValueIsStepList" },
                    { kind: "block", type: "ValueIsParameter" },
                    { kind: "block", type: "ValueIsParameterList" },
                    { kind: "block", type: "ValueIsWikipediaURL" },
                    { kind: "block", type: "ValueIsWikipediaPageName" },
                    { kind: "block", type: "JSONinText" },
                    { kind: "block", type: "HTMLtoText" },
                    { kind: "block", type: "TextOfWebDocument" },
                    { kind: "block", type: "TextOfWikipediaArticle" },
                    { kind: "block", type: "WebSearch" },
                    { kind: "block", type: "WikipediaSearch" },
                ]
            }, {
                kind: "category",
                name: "Miscellany",
                contents: [
                    { kind: "block", type: "nop" },
                    { kind: "block", type: "throwException" },
                    { kind: "block", type: "wait" },
                    { kind: "block", type: "alert" },
                    { kind: "block", type: "confirm" },
                    { kind: "block", type: "prompt" },
                    { kind: "block", type: "prompt_with_default" },
                    { kind: "block", type: "speak" },
                    { kind: "block", type: "ValueIsNotEmpty" },
                    { kind: "block", type: "ValueIsNumber" },
                    { kind: "block", type: "ValueIsNumberInRange" },
                    { kind: "block", type: "ValueIsInteger" },
                    { kind: "block", type: "ValueIsIntegerInRange" },
                    { kind: "block", type: "ValueIsOrdinal" },
                    { kind: "block", type: "ValueIsCardinal" },
                    { kind: "block", type: "ValueIsStringMatching" },
                    { kind: "block", type: "ValueIsURL" },
                ]
            },
            {
                kind: "category",
                name: "Variables",
                custom: "VARIABLE"
            }, {
                kind: "category",
                name: "Functions",
                custom: "PROCEDURE"
            }
        ]
    },
    //  plugins:...,
};
//------------------------------------------------------------------------------
//--                              PlaygroundView                              --
//------------------------------------------------------------------------------
class PlaygroundView extends Component {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { Value: 0 }
        });
    }
    rerender() {
        this.setState({ Value: this.state.Value + 1 });
    }
    componentDidMount() {
        Playground.View = this;
        Playground.WorkspaceElement = this.base.querySelector('.Playground.Workspace > .Placeholder');
        const Workspace = Playground.Workspace = Blockly.inject(Playground.WorkspaceElement, WorkspaceSpecification);
        restoreWorkspace();
        Workspace.addChangeListener(preserveWorkspace);
        //    Playground.Workspace = Workspace
    }
    render() {
        const { activeTab } = Playground;
        function onChange(Event) {
            loadExample(Event.target.value);
            Event.target.value = "";
        }
        return html `<div class="Playground View">
        <div class="Playground Title">Blockly AI Playground</div>
        <div class="Playground Strip">
          <div class="Playground Tab ${activeTab === 0 ? 'active' : ''}"
            onClick=${() => { Playground.activeTab = 0; this.rerender(); }}
          >Workspace</>
            <div style="display:inline-block; width:10px"/>
          <div class="Playground Tab ${activeTab === 1 ? 'active' : ''}"
            onClick=${() => { Playground.activeTab = 1; this.rerender(); }}
          >User Interface</>
            <div class="Playground Gap"/>
          <span>load Example</span>
          <select id="ExampleLoader" style="max-width:190px; margin-left:4px"
            onChange=${onChange}
          >
            <option value="" disabled selected>(please select)</option>
            <option value="basicSettings">basic Settings</option>
            <option value="PoC">Proof-of-Concept</option>
            <option value="AIWebSearch">AI-assisted Web Search</option>
            <option value="AIAgent">AI Agent</option>
            <option value="" disabled>----</option>
            <option value="AIResearchTool">ResearchTool</option>
            <option value="AIComputationTool">ComputationTool</option>
            <option value="" disabled>----</option>
            <option value="TextSummarizer">Text Summarizer</option>
            <option value="SearchPhraseGenerator">Search Phrase Generator</option>
            <option value="InformationExtractor">Information Extractor</option>
            <option value="InformationValidator">Information Validator</option>
            <option value="ParameterListGenerator">Parameter List Generator</option>
            <option value="FunctionGenerator">Function Generator</option>
            <option value="TaskDecomposer_I">Task Decomposer (w/o prior knowledge)</option>
            <option value="TaskDecomposer_II">Task Decomposer (w/ prior knowledge)</option>
            <option value="KnowledgeGenerator">Knowledge Generator</option>
            <option value="AnswerGenerator">Answer Generator</option>
            <option value="" disabled>----</option>
            <option value="TextCompletion">Text Completion</option>
            <option value="ChatCompletion">Chat Completion</option>
          </select>
            <div class="Playground Gap"/>
          <button class="Playground Button" style="width:80px"
            disabled=${Playground.pendingInterpreterState != null}
            onClick=${() => {
            switch (Playground.InterpreterState) {
                case 'idle':
                    startBlocklyProgram();
                    break;
                case 'running':
                    suspendBlocklyProgram();
                    break;
                case 'suspended':
                    resumeBlocklyProgram();
                    break;
            }
        }}
          >${Playground.InterpreterState === 'idle' ? 'Start' :
            Playground.InterpreterState === 'running' ? 'Suspend' : 'Resume'}</>
            <div style="display:inline-block; width:10px"/>
          <button class="Playground Button" style="width:80px"
            disabled=${Playground.InterpreterState === 'idle'}
            onClick=${abortBlocklyProgram}
          >Abort</>
        </>
        <div class="Playground Arena">
          <div class="Playground Workspace ${activeTab === 0 ? 'active' : ''}">
            <div class="Placeholder"/>
            <div class="Playground Strip">
              <input type="checkbox"
                checked=${Playground.BackupWanted}
                onClick=${(Event) => updatePlaygroundBackup(Event.target.checked)}
              />
              <span>save Workspace in Browser</span>
                <div class="Playground Gap"/>
              <div style="display:inline-block; position:relative">
                <button class="Playground Button" style="width:80px; pointer-events:none"
                >Upload</>
                <label class="Playground FileInput">
                  <input type="file" class="Playground FileInput" style="display:none"
                    accept=".json,application/json"
                    onChange=${(Event) => uploadWorkspaceFrom(Event.target.files[0])}
                  />
                </>
              </>
                <div style="display:inline-block; width:10px"/>
              <button class="Playground Button" style="width:80px"
                onClick=${downloadWorkspace}
              >Download</>
            </>
          </>
          <div class="Playground UI ${activeTab === 1 ? 'active' : ''}">
            ${Playground.UI.map((Item) => html `<${PlaygroundUIItemView} Item=${Item}/>`)}
          </>
        </>
      </>`;
    }
}
/**** PlaygroundUIItemView ****/
class PlaygroundUIItemView extends Component {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { Value: 0 }
        });
        Object.defineProperty(this, "View", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    rerender() {
        this.setState({ Value: this.state.Value + 1 });
    }
    componentDidMount() {
        this.View = this.base;
    }
    componentWillUnmount() {
        this.View = undefined;
    }
    render(PropSet) {
        const { Item } = PropSet;
        switch (Item.Type) {
            case 'textline-input': return html `<${TextlineInputItem} Item=${Item}/>`;
            case 'password-input': return html `<${PasswordInputItem} Item=${Item}/>`;
            case 'number-input': return html `<${NumberInputItem} Item=${Item}/>`;
            case 'url-input': return html `<${URLInputItem} Item=${Item}/>`;
            case 'text-input': return html `<${TextInputItem} Item=${Item}/>`;
            case 'speech-input': return html `<${SpeechInputItem} Item=${Item}/>`;
            case 'checkbox': return html `<${CheckboxItem} Item=${Item}/>`;
            case 'radiobutton-group': return html `<${RadiobuttonGroupItem} Item=${Item}/>`;
            case 'dropdown': return html `<${DropDownItem} Item=${Item}/>`;
            case 'button': return html `<${ButtonItem} Item=${Item}/>`;
            case 'textline-output': return html `<${TextlineOutputItem} Item=${Item}/>`;
            case 'number-output': return html `<${NumberOutputItem} Item=${Item}/>`;
            case 'text-output': return html `<${TextOutputItem} Item=${Item}/>`;
            case 'fineprint-output': return html `<${FinePrintOutputItem} Item=${Item}/>`;
            case 'text': return html `<${TextViewItem} Item=${Item}/>`;
            case 'fineprint': return html `<${FinePrintViewItem} Item=${Item}/>`;
            case 'api-server-input': return html `<${APIServerInputItem} Item=${Item}/>`;
            default: throwError('InvalidArgument: missing or invalid "Item.Type"');
        }
        return undefined;
    }
}
/**** TextlineInputItem ****/
class TextlineInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const Pattern = acceptableOptionalTextline(OptionSet.Pattern);
        const SpellChecking = acceptableOptionalBoolean(OptionSet.SpellChecking);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Suggestions = acceptableOptionalListSatisfying(OptionSet.Suggestions, undefined, ValueIsTextline);
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            my.ValueToShow = acceptableTextline(getFromContext(Key), '');
        }
        let SuggestionList = '', SuggestionId;
        if ((Suggestions != null) && (Suggestions.length > 0)) {
            SuggestionId = Key + '-Suggestions';
            SuggestionList = html `<datalist id=${SuggestionId}>
          ${Suggestions.map((Value) => html `<option value=${Value}></option>`)}
        </datalist>`;
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="text" class="Playground UI Element TextlineInput"
          value=${my.ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly=${readonly} placeholder=${Placeholder}
          pattern=${Pattern} spellcheck=${SpellChecking}
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
          list=${SuggestionId}
        />${SuggestionList}
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** PasswordInputItem ****/
class PasswordInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const Pattern = acceptableOptionalTextline(OptionSet.Pattern);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            my.ValueToShow = acceptableTextline(getFromContext(Key), '');
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="password" class="Playground UI Element PasswordInput"
          value=${my.ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly=${readonly} placeholder=${Placeholder}
          pattern=${Pattern}
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
        />
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** NumberInputItem ****/
class NumberInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const Minimum = acceptableOptionalNumber(OptionSet.Minimum);
        const Stepping = acceptableOptionalNumberInRange(OptionSet.Stepping, undefined, 0);
        const Maximum = acceptableOptionalNumber(OptionSet.Maximum);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Suggestions = acceptableOptionalListSatisfying(OptionSet.Suggestions, undefined, ValueIsNumber);
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            const Candidate = getFromContext(Key);
            my.ValueToShow = acceptableNumber(ValueIsString(Candidate) ? parseFloat(Candidate) : Candidate, 0);
        }
        let SuggestionList = '', SuggestionId;
        if ((Suggestions != null) && (Suggestions.length > 0)) {
            SuggestionId = Key + '-Suggestions';
            SuggestionList = html `<datalist id=${SuggestionId}>
          ${Suggestions.map((Value) => html `<option value=${Value}></option>`)}
        </datalist>`;
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="number" class="Playground UI Element NumberInput"
          value=${my.ValueToShow} min=${Minimum} max=${Maximum} step=${Stepping}
          readOnly=${readonly} placeholder=${Placeholder}
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
          list=${SuggestionId}
        />${SuggestionList}
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** URLInputItem ****/
class URLInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const Pattern = acceptableOptionalTextline(OptionSet.Pattern);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Suggestions = acceptableOptionalListSatisfying(OptionSet.Suggestions, undefined, ValueIsURL);
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            my.ValueToShow = acceptableTextline(getFromContext(Key), '');
        }
        let SuggestionList = '', SuggestionId;
        if ((Suggestions != null) && (Suggestions.length > 0)) {
            SuggestionId = Key + '-Suggestions';
            SuggestionList = html `<datalist id=${SuggestionId}>
          ${Suggestions.map((Value) => html `<option value=${Value}></option>`)}
        </datalist>`;
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="url" class="Playground UI Element URLInput"
          value=${my.ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly=${readonly} placeholder=${Placeholder}
          pattern=${Pattern}
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
          list=${SuggestionId}
        />${SuggestionList}
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** TextInputItem ****/
class TextInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const LineWrapping = acceptableOptionalBoolean(OptionSet.LineWrapping);
        const SpellChecking = acceptableOptionalBoolean(OptionSet.SpellChecking);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            my.ValueToShow = acceptableText(getFromContext(Key), '');
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <textarea class="Playground UI Element TextInput"
          value=${my.ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly=${readonly} placeholder=${Placeholder}
          spellcheck=${SpellChecking} style="${LineWrapping == true
            ? 'white-space:pre; overflow-wrap:break-word; hyphens:auto'
            : undefined}"
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
        />
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** CheckboxItem ****/
class CheckboxItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        let ValueToShow = acceptableString(getFromContext(Key), 'false');
        function onClick(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, '' + Event.target.checked);
            enqueueUIEvent('input', Key);
        }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="checkbox" class="Playground UI Element Checkbox"
          checked=${ValueToShow === 'true'}
          disabled=${Enabling == false} onClick=${onClick}
        />
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** RadiobuttonGroupItem ****/
class RadiobuttonGroupItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Choices = acceptableText(OptionSet.Choices, '').split('\n')
            .map((Choice) => Choice.trim())
            .filter((Choice) => Choice !== '');
        const GroupName = Key + '-Group';
        let selectedIndex = parseInt(acceptableString(getFromContext(Key), '-1'));
        function onClick(Event, Index) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, '' + Index);
            enqueueUIEvent('input', Key);
        }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="radio" class="Playground UI Element Radiobutton"
          name=${GroupName} checked=${selectedIndex === 0}
          disabled=${Enabling == false} onClick=${(Event) => onClick(Event, 0)}
        />
        <span style="margin-left:4px; line-height:30px">${Choices[0]}</span>
        <div class="Playground UI newLine"/>
        ${Choices.slice(1).map((Choice, Index) => html `
          <div class="Playground UI Label"/>
          <input type="radio" class="Playground UI Element Radiobutton"
            name=${GroupName} checked=${selectedIndex === (Index + 1)}
            disabled=${Enabling == false} onClick=${(Event) => onClick(Event, Index + 1)}
          />
          <span style="margin-left:4px; line-height:30px">${Choice}</span>
          <div class="Playground UI newLine"/>
        `)}
      `;
    }
}
/**** DropDownItem ****/
class DropDownItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Choices = acceptableText(OptionSet.Choices, '').split('\n')
            .map((Choice) => Choice.trim())
            .filter((Choice) => Choice !== '');
        let selectedIndex = parseInt(acceptableString(getFromContext(Key), '-1'), 10);
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, '' + Event.target.selectedIndex);
            enqueueUIEvent('input', Key);
        }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <select class="Playground UI Element DropDown"
          disabled=${Enabling == false} onInput=${onInput}
        >
        ${Choices.map((Choice, Index) => html `
          <option selected=${Index === selectedIndex}>${Choice}</>
        `)}
        </>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** ButtonItem ****/
class ButtonItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        let ValueToShow = acceptableTextline(getFromContext(Key), 'Button');
        function onClick(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            enqueueUIEvent('click', Key);
        }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <button class="Playground UI Element Button"
          disabled=${Enabling == false} onClick=${onClick}
        >${ValueToShow}</>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** TextlineOutputItem ****/
class TextlineOutputItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        let ValueToShow = acceptableTextline(getFromContext(Key), '');
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="text" class="Playground UI Element TextlineOutput"
          value=${ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly placeholder=${Placeholder}
          disabled=${Enabling == false}
        />
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** NumberOutputItem ****/
class NumberOutputItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const Minimum = acceptableOptionalNumber(OptionSet.Minimum);
        const Stepping = acceptableOptionalNumberInRange(OptionSet.Stepping, undefined, 0);
        const Maximum = acceptableOptionalNumber(OptionSet.Maximum);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const Candidate = getFromContext(Key);
        let ValueToShow = acceptableNumber(ValueIsString(Candidate) ? parseFloat(Candidate) : Candidate, 0);
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="number" class="Playground UI Element NumberOutput"
          value=${ValueToShow} min=${Minimum} max=${Maximum} step=${Stepping}
          readOnly placeholder=${Placeholder}
          disabled=${Enabling == false}
        />
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** TextOutputItem ****/
class TextOutputItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const LineWrapping = acceptableOptionalBoolean(OptionSet.LineWrapping);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        let ValueToShow = acceptableText(getFromContext(Key), '');
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <textarea class="Playground UI Element TextOutput"
          minlength=${minLength} maxlength=${maxLength}
          readOnly placeholder=${Placeholder}
          style="${LineWrapping == true
            ? 'white-space:pre; overflow-wrap:break-word; hyphens:auto'
            : undefined}"
          disabled=${Enabling == false}
        >${ValueToShow}</>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** FinePrintOutputItem ****/
class FinePrintOutputItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const LineWrapping = acceptableOptionalBoolean(OptionSet.LineWrapping);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        let ValueToShow = acceptableText(getFromContext(Key), '');
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <div class="Playground UI Element FinePrintOutput">
          ${ValueToShow}
        </>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** TextViewItem ****/
class TextViewItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const Key = Item.Key;
        let ValueToShow = acceptableText(getFromContext(Key), '');
        return html `
        <div class="Playground UI Element TextView">
          ${ValueToShow}
        </>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** FinePrintViewItem ****/
class FinePrintViewItem extends PlaygroundUIItemView {
    render(PropSet) {
        const { Item } = PropSet;
        const Key = Item.Key;
        let ValueToShow = acceptableText(getFromContext(Key), '');
        return html `
        <div class="Playground UI Element FinePrintView">
          ${ValueToShow}
        </>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** APIServerInputItem ****/
class APIServerInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "ValueToShow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    render(PropSet) {
        const my = this, me = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = 'APIServer';
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const readonly = acceptableOptionalBoolean(OptionSet.readonly);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const Pattern = acceptableOptionalTextline(OptionSet.Pattern);
        const Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        if ((document.activeElement == null) ||
            !document.activeElement.contains(my.View)) {
            my.ValueToShow = acceptableTextline(getFromContext(Key), '');
        }
        function onInput(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            enqueueUIEvent('input', Key);
        }
        function onChange(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            setInContext(Key, Event.target.value);
            Event.target.value = '';
            enqueueUIEvent('input', Key);
        }
        function onBlur() { me.rerender(); }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <input type="url" class="Playground UI Element URLInput"
          value=${my.ValueToShow} minlength=${minLength} maxlength=${maxLength}
          readOnly=${readonly} placeholder=${Placeholder}
          pattern=${Pattern}
          disabled=${Enabling == false} onInput=${onInput} onBlur=${onBlur}
        />
        <select onChange=${onChange} style="
          display:inline-block; position:relative;
          top:1px; height:28px; margin-left:4px;
        ">
          <option value="" selected disabled>(select)</option>
          <option value="https://api.openai.com/v1/chat/completions">Open AI</option>
          <option value="https://api.perplexity.ai/chat/completions">Perplexity AI</option>
          <option value="http://127.0.0.1:11434/api/chat">local Ollama</option>
        </select>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** SpeechInputItem ****/
class SpeechInputItem extends PlaygroundUIItemView {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "listening", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "Recognition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    render(PropSet) {
        const Iam = this, my = this;
        const { Item } = PropSet;
        const { OptionSet } = Item;
        const Key = Item.Key;
        const Placeholder = acceptableOptionalTextline(OptionSet.Placeholder);
        const minLength = acceptableOptionalOrdinal(OptionSet.minLength);
        const maxLength = acceptableOptionalOrdinal(OptionSet.maxLength);
        const LineWrapping = acceptableOptionalBoolean(OptionSet.LineWrapping);
        let Enabling = acceptableBoolean(OptionSet.Enabling, true) && Playground.UIEnabling;
        const SpeechRecognition = (
        // @ts-ignore TS2339 don#t worry about [webkit]SpeechRecognition
        window.SpeechRecognition || window.webkitSpeechRecognition);
        Enabling = Enabling && (SpeechRecognition != null);
        let ValueToShow = acceptableText(getFromContext(Key), '');
        if (!Iam.listening && (SpeechRecognition != null)) {
            const Recognition = new SpeechRecognition();
            Recognition.lang = 'en';
            Recognition.continuous = false;
            Recognition.interimResults = false;
            Recognition.onresult = (Event) => {
                setInContext(Key, Event.results[0][0].transcript);
                enqueueUIEvent('input', Key);
            };
            Recognition.onerror = (Event) => {
                Playground.thrownException = Event.error;
                console.log('speech recognition error', Event.error, Event.message);
                //            throwError('SppechRecognitionFailure: speech recognition failed')
            };
            Recognition.onspeechend = () => {
                Recognition.stop();
            };
            Recognition.onend = () => {
                Iam.listening = false;
                rerenderPlayground();
            };
            my.Recognition = Recognition;
        }
        function onClick(Event) {
            if (Enabling == false) {
                return consumingEvent(Event);
            }
            if (Iam.listening) {
                my.Recognition.stop();
            }
            else {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then((Stream) => {
                    Stream.getTracks().forEach((Track) => Track.stop());
                })
                    .then(() => {
                    Iam.listening = true;
                    rerenderPlayground();
                    my.Recognition.start();
                });
            }
        }
        return html `
        <div class="Playground UI Label">${Item.Label}</>
        <button class="Playground UI Element Button"
          disabled=${Enabling == false} onClick=${onClick}
        >${Iam.listening ? 'Stop' : 'Listen'}</>
        <div class="Playground UI newLine"/>
        <div class="Playground UI Label"></>
        <textarea class="Playground UI Element TextOutput"
          minlength=${minLength} maxlength=${maxLength}
          readOnly placeholder=${Placeholder}
          style="${LineWrapping == true
            ? 'white-space:pre; overflow-wrap:break-word; hyphens:auto'
            : undefined}"
          disabled=${Enabling == false}
        >${ValueToShow}</>
        <div class="Playground UI newLine"/>
      `;
    }
}
/**** preserveWorkspace ****/
function preserveWorkspace() {
    const WorkspaceSerialization = JSON.stringify(Blockly.serialization.workspaces.save(Playground.Workspace));
    sessionStorage.setItem('blockly-ai-playground', WorkspaceSerialization);
    if (Playground.BackupWanted) {
        localStorage.setItem('blockly-ai-playground', WorkspaceSerialization);
    }
}
/**** restoreWorkspace ****/
function restoreWorkspace() {
    Playground.Workspace.clear();
    const WorkspaceSerialization = (Playground.BackupWanted
        ? localStorage.getItem('blockly-ai-playground')
        : sessionStorage.getItem('blockly-ai-playground')) || '{}';
    if (WorkspaceSerialization.trim() !== '{}') {
        try {
            Blockly.serialization.workspaces.load(JSON.parse(WorkspaceSerialization), Playground.Workspace);
        }
        catch (Signal) {
            console.error('Blockly Workspace Deserialization Error', Signal);
        }
    }
}
/**** updatePlaygroundBackup ****/
Playground.BackupWanted = localStorage.getItem('blockly-ai-playground_wants_backup');
function updatePlaygroundBackup(BackupWanted) {
    Playground.BackupWanted = BackupWanted;
    if (BackupWanted) {
        localStorage.setItem('blockly-ai-playground_wants_backup', 'true');
        preserveWorkspace();
    }
    else {
        localStorage.removeItem('blockly-ai-playground_wants_backup');
        localStorage.removeItem('blockly-ai-playground');
    }
}
/**** uploadWorkspaceFrom ****/
function uploadWorkspaceFrom(File) {
    let Reader = new FileReader();
    Reader.onabort = function LoadAborted() { window.alert('Upload was aborted'); };
    Reader.onerror = function LoadFailed() { window.alert('Upload failed'); };
    Reader.onload = function FileLoaded(Event) {
        Playground.Workspace.clear();
        let FileValue = (new TextDecoder()).decode(Reader.result);
        try {
            let Serialization = JSON.parse(FileValue);
            Blockly.serialization.workspaces.load(Serialization, Playground.Workspace);
        }
        catch (Signal) {
            console.error('Blockly Workspace Upload failed', Signal);
            window.alert('Upload failed\n\n' + Signal);
        }
    };
    Reader.readAsArrayBuffer(File);
}
/**** downloadWorkspace ****/
function downloadWorkspace() {
    const WorkspaceSerialization = JSON.stringify(Blockly.serialization.workspaces.save(Playground.Workspace));
    const encodedDownload = (new TextEncoder()).encode(WorkspaceSerialization);
    const decodedDownload = (new TextDecoder()).decode(encodedDownload);
    if (WorkspaceSerialization === decodedDownload) {
        download(encodedDownload, 'Blockly-AI-Playground.json', 'application/json;charset=utf-8');
    }
    else {
        window.alert('Download is not safe');
    }
}
/**** loadExample ****/
async function loadExample(Example) {
    Playground.Workspace.clear();
    showWorkspace();
    try {
        const URL = ('https://rozek.github.io/blockly-ai-playground/Examples/' +
            Example +
            '.json');
        const Response = await fetch(URL); // may fail!
        const Serialization = await Response.text();
        Blockly.serialization.workspaces.load(JSON.parse(Serialization), Playground.Workspace);
    }
    catch (Signal) {
        window.alert('Could not load the requested Example\n\nReason: ' + Signal);
    }
}
function SetFromKeyValueList(List) {
    expectListSatisfying('key value list', List, ValueIsKeyValuePair);
    const Result = {};
    List.forEach((Pair) => Result[Pair[0]] = Pair[1]);
    return Result;
}
/**** ValueIsKeyValuePair ****/
function ValueIsKeyValuePair(Value) {
    return (ValueIsList(Value) && (Value.length === 2) &&
        ValueIsIdentifier(Value[0]));
}
/**** consume/consumingEvent ****/
function consumeEvent(Event) {
    Event.stopPropagation();
    Event.preventDefault();
}
const consumingEvent = consumeEvent;
render(html `<${PlaygroundView}/>`, document.body);

  </script>
 </body>
</html>

